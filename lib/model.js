// Generated by CoffeeScript 1.3.3
(function() {
  var $, Deferred, IS_NODE, Model, PathInfo, Table, intermine, liftToTable, omap, _, __root__, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  IS_NODE = typeof exports !== 'undefined';

  __root__ = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (IS_NODE) {
    intermine = exports;
    _ = require('underscore')._;
    Deferred = ($ = require('underscore.deferred')).Deferred;
    Table = require('./table').Table;
    PathInfo = require('./path').PathInfo;
    omap = require('./util').omap;
  } else {
    _ = __root__._;
    Deferred = ($ = __root__.jQuery).Deferred;
    intermine = ((_ref = __root__.intermine) != null ? _ref : __root__.intermine = {});
    Table = intermine.Table, PathInfo = intermine.PathInfo;
    omap = intermine.funcutils.omap;
  }

  liftToTable = omap(function(k, v) {
    return [k, new Table(v)];
  });

  Model = (function() {

    function Model(_arg) {
      var classes;
      this.name = _arg.name, classes = _arg.classes;
      this.findSharedAncestor = __bind(this.findSharedAncestor, this);

      this.classes = liftToTable(classes);
    }

    Model.prototype.getPathInfo = function(path, subcls) {
      return PathInfo.parse(this, path, subcls);
    };

    Model.prototype.getSubclassesOf = function(cls) {
      var cd, clazz, ret, _ref1, _ref2;
      clazz = cls && cls.name ? cls : this.classes[cls];
      if (clazz == null) {
        throw new Error("" + cls + " is not a table");
      }
      ret = [clazz.name];
      _ref1 = this.classes;
      for (_ in _ref1) {
        cd = _ref1[_];
        if (_ref2 = clazz.name, __indexOf.call(cd.superClasses, _ref2) >= 0) {
          ret = ret.concat(this.getSubclassesOf(cd));
        }
      }
      return ret;
    };

    Model.prototype.getAncestorsOf = function(cls) {
      var ancestors, clazz, superC, _i, _len, _ref1;
      clazz = cls && cls.name ? cls : this.classes[cls];
      if (clazz == null) {
        throw new Error("" + cls + " is not a table");
      }
      ancestors = clazz.superClasses.slice();
      _ref1 = clazz.superClasses;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        superC = _ref1[_i];
        ancestors.push(this.getAncestorsOf(superC));
      }
      return _.flatten(ancestors);
    };

    Model.prototype.findSharedAncestor = function(classA, classB) {
      var a_ancestry, b_ancestry;
      if (classB === null || classA === null || classA === classB) {
        return null;
      }
      a_ancestry = this.getAncestorsOf(classA);
      b_ancestry = this.getAncestorsOf(classB);
      if (__indexOf.call(a_ancestry, classB) >= 0) {
        return classB;
      }
      if (__indexOf.call(b_ancestry, classA) >= 0) {
        return classA;
      }
      return _.intersection(a_ancestry, b_ancestry).shift();
    };

    Model.prototype.findCommonType = function(xs) {
      return xs.reduce(this.findSharedAncestor);
    };

    return Model;

  })();

  Model.prototype.makePath = Model.prototype.getPathInfo;

  Model.prototype.findCommonTypeOfMultipleClasses = Model.prototype.findCommonType;

  Model.load = function(data) {
    return new Model(data);
  };

  Model.NUMERIC_TYPES = ["int", "Integer", "double", "Double", "float", "Float"];

  Model.INTEGRAL_TYPES = ["int", "Integer"];

  Model.BOOLEAN_TYPES = ["boolean", "Boolean"];

  intermine.Model = Model;

}).call(this);
