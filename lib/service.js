// Generated by CoffeeScript 1.3.3
(function() {
  var $, ACCEPT_HEADER, BufferedResponse, CHECKING_PIPE, DEFAULT_ERROR_HANDLER, DEFAULT_PROTOCOL, Deferred, ENRICHMENT_PATH, ERROR_PIPE, EventEmitter, HAS_PROTOCOL, HAS_SUFFIX, IDENTITY, IS_NODE, LISTS_PATH, LIST_OPERATION_PATHS, List, MODELS, MODEL_PATH, Model, PREF_PATH, QUERY_RESULTS_PATH, QUICKSEARCH_PATH, Query, REQUIRES, SUFFIX, SUMMARYFIELDS_PATH, SUMMARY_FIELDS, Service, TABLE_ROW_PATH, TEMPLATES_PATH, URL, URLENC, User, VERSIONS, VERSION_PATH, WHOAMI_PATH, WIDGETS, WIDGETS_PATH, WITH_OBJ_PATH, dejoin, get, getListFinder, http, intermine, invoke, jQuery, modeller, qs, root, set, to_query_string, wire_for_browser, wire_for_node, _, _get_or_fetch, _ref, _ref1, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  IS_NODE = typeof exports !== 'undefined';

  ACCEPT_HEADER = {
    "json": "application/json",
    "jsonobjects": "application/json;type=objects",
    "jsontable": "application/json;type=table",
    "jsonrows": "application/json;type=rows",
    "jsoncount": "application/json;type=count",
    "jsonp": "application/javascript",
    "jsonpobjects": "application/javascript;type=objects",
    "jsonptable": "application/javascript;type=table",
    "jsonprows": "application/javascript;type=rows",
    "jsonpcount": "application/javascript;type=count"
  };

  URLENC = "application/x-www-form-urlencoded";

  if (IS_NODE) {
    _ = require('underscore')._;
    Deferred = ($ = require('underscore.deferred')).Deferred;
    http = require('http');
    URL = require('url');
    qs = require('querystring');
    Model = require('./model').Model;
    Query = require('./query').Query;
    List = require('./lists').List;
    User = require('./user').User;
    _ref = require('./shiv'), get = _ref.get, set = _ref.set, invoke = _ref.invoke;
    EventEmitter = require('events').EventEmitter;
    BufferedResponse = require('buffered-response').BufferedResponse;
    to_query_string = qs.stringify;
    intermine = exports;
  } else {
    _ = root._, jQuery = root.jQuery;
    Deferred = ($ = jQuery).Deferred;
    if ((_ref1 = root.intermine) == null) {
      root.intermine = {};
    }
    to_query_string = jQuery.param;
    _ref2 = root.intermine, Model = _ref2.Model, Query = _ref2.Query, List = _ref2.List, User = _ref2.User;
    _ref3 = root.intermine.funcutils, get = _ref3.get, set = _ref3.set, invoke = _ref3.invoke;
    (function() {
      var converters, format, header;
      converters = {};
      for (format in ACCEPT_HEADER) {
        header = ACCEPT_HEADER[format];
        converters["text " + format] = jQuery.parseJSON;
      }
      return jQuery.ajaxSetup({
        accepts: ACCEPT_HEADER,
        contents: {
          json: /json/
        },
        converters: converters
      });
    })();
    intermine = root.intermine;
  }

  modeller = function(x) {
    if (Model != null) {
      return new Model(x);
    } else {
      return x;
    }
  };

  VERSIONS = {};

  MODELS = {};

  SUMMARY_FIELDS = {};

  WIDGETS = {};

  DEFAULT_PROTOCOL = "http://";

  VERSION_PATH = "version";

  TEMPLATES_PATH = "templates";

  LISTS_PATH = "lists";

  MODEL_PATH = "model";

  SUMMARYFIELDS_PATH = "summaryfields";

  QUERY_RESULTS_PATH = "query/results";

  QUICKSEARCH_PATH = "search";

  WIDGETS_PATH = "widgets";

  ENRICHMENT_PATH = "list/enrichment";

  WITH_OBJ_PATH = "listswithobject";

  LIST_OPERATION_PATHS = {
    merge: "lists/union",
    intersect: "lists/intersect",
    diff: "lists/diff"
  };

  WHOAMI_PATH = "user/whoami";

  TABLE_ROW_PATH = QUERY_RESULTS_PATH + '/tablerows';

  PREF_PATH = 'user/preferences';

  REQUIRES = function(required, got) {
    return "This service requires a service at version " + required + " or above. This one is at " + got;
  };

  IDENTITY = function(x) {
    return x;
  };

  HAS_PROTOCOL = /^https?:\/\//i;

  HAS_SUFFIX = /service\/?$/i;

  SUFFIX = "/service/";

  DEFAULT_ERROR_HANDLER = function(e) {
    var _ref4;
    if (IS_NODE && (e.stack != null)) {
      return console.error(e.stack);
    } else {
      if (typeof console !== "undefined" && console !== null) {
        return (_ref4 = console.error || console.log) != null ? _ref4.apply(console, arguments) : void 0;
      }
    }
  };

  ERROR_PIPE = function(xhr, textStatus, e) {
    try {
      return JSON.parse(xhr.responseText).error;
    } catch (e) {
      return textStatus;
    }
  };

  CHECKING_PIPE = function(response) {
    return Deferred(function() {
      if (response.wasSuccessful) {
        try {
          return this.resolve(response);
        } catch (e) {
          return this.reject(e, response);
        }
      } else {
        return this.reject(response.error, response);
      }
    });
  };

  dejoin = function(q) {
    var parts, view, _i, _len, _ref4;
    _ref4 = q.views;
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      view = _ref4[_i];
      parts = view.split('.');
      if (parts.length > 2) {
        q.addJoin(parts.slice(1, -1).join('.'));
      }
    }
    return q;
  };

  _get_or_fetch = function(propName, store, path, key, cb) {
    var value, _ref4,
      _this = this;
    return (_ref4 = this[propName]) != null ? _ref4 : this[propName] = this.useCache && (value = store[this.root]) ? Deferred().resolve(value).promise().done(cb) : this.get(path).pipe(get(key)).done(cb, function(x) {
      return store[_this.root] = x;
    });
  };

  getListFinder = function(name) {
    return function(lists) {
      return Deferred(function() {
        var list;
        if (list = _.find(lists, function(l) {
          return l.name === name;
        })) {
          return this.resolve(list);
        } else {
          return this.reject("List \"" + name + "\" not found among: " + (lists.map(get('name'))));
        }
      });
    };
  };

  Service = (function() {

    function Service(_arg) {
      var loc, noCache, _ref4, _ref5,
        _this = this;
      this.root = _arg.root, this.token = _arg.token, this.errorHandler = _arg.errorHandler, this.DEBUG = _arg.DEBUG, this.help = _arg.help, noCache = _arg.noCache;
      this.query = __bind(this.query, this);

      this.fetchListsContaining = __bind(this.fetchListsContaining, this);

      this.fetchList = __bind(this.fetchList, this);

      this.fetchTemplates = __bind(this.fetchTemplates, this);

      this.tableRows = __bind(this.tableRows, this);

      this.rows = __bind(this.rows, this);

      this.records = __bind(this.records, this);

      this.table = __bind(this.table, this);

      this.findById = __bind(this.findById, this);

      this.count = __bind(this.count, this);

      if (this.root == null) {
        throw new Error("No service root provided. This is required");
      }
      if (!HAS_PROTOCOL.test(this.root)) {
        this.root = DEFAULT_PROTOCOL + this.root;
      }
      if (!HAS_SUFFIX.test(this.root)) {
        this.root = this.root + SUFFIX;
      }
      this.root = this.root.replace(/ics$/, "ice/");
      if ((_ref4 = this.errorHandler) == null) {
        this.errorHandler = DEFAULT_ERROR_HANDLER;
      }
      if ((_ref5 = this.help) == null) {
        this.help = 'no.help.available@dev.null';
      }
      this.useCache = !noCache;
      loc = IS_NODE ? '' : location.protocol + '//' + location.host;
      this.getFormat = function(intended) {
        if (intended == null) {
          intended = 'json';
        }
        if (!/jsonp/.test(intended)) {
          if (!(IS_NODE || jQuery.support.cors)) {
            if (loc.substring(0, _this.root.length) !== _this.root) {
              return intended.replace('json', 'jsonp');
            }
          }
        }
        return intended;
      };
    }

    Service.prototype.post = function(path, data) {
      if (data == null) {
        data = {};
      }
      return this.makeRequest('POST', path, data);
    };

    Service.prototype.get = function(path, data) {
      return this.makeRequest('GET', path, data);
    };

    Service.prototype.makeRequest = function(method, path, data, cb, indiv) {
      var errBack, opts, url, _ref4;
      if (method == null) {
        method = 'GET';
      }
      if (path == null) {
        path = '';
      }
      if (data == null) {
        data = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (indiv == null) {
        indiv = false;
      }
      if (_.isArray(cb)) {
        _ref4 = cb, cb = _ref4[0], errBack = _ref4[1];
      }
      if (_.isArray(data)) {
        data = _.foldl(data, (function(m, _arg) {
          var k, v;
          k = _arg[0], v = _arg[1];
          m[k] = v;
          return m;
        }), {});
      }
      url = this.root + path;
      if (errBack == null) {
        errBack = this.errorHandler;
      }
      if (this.token) {
        data.token = this.token;
      }
      data.format = this.getFormat(data.format);
      if (/jsonp/.test(data.format)) {
        data.method = method;
        method = 'GET';
        url += '?callback=?';
      }
      if (!this.supports(method)) {
        data.method = method;
        method = this.getEffectiveMethod(method);
      }
      if (method === 'DELETE') {
        url += '?' + to_query_string(data);
      }
      opts = {
        data: data,
        dataType: data.format,
        success: cb,
        error: errBack,
        url: url,
        type: method
      };
      return this.doReq(opts, indiv);
    };

    Service.prototype.supports = function() {
      return true;
    };

    Service.prototype.getEffectiveMethod = function(x) {
      return x;
    };

    Service.prototype.enrichment = function(opts, cb) {
      return this.get(ENRICHMENT_PATH, _.defaults({}, opts, {
        maxp: 0.05
      })).pipe(get('results'));
    };

    Service.prototype.search = function(options, cb) {
      var k, req, v, _ref4, _ref5;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (_.isFunction(options)) {
        _ref4 = [options, {}], cb = _ref4[0], options = _ref4[1];
      }
      if (_.isString(options)) {
        options = {
          q: options
        };
      }
      req = _.defaults({}, options, {
        q: ''
      });
      delete req.facets;
      if (options.facets) {
        _ref5 = options.facets;
        for (k in _ref5) {
          v = _ref5[k];
          req["facet_" + k] = v;
        }
      }
      return this.post(QUICKSEARCH_PATH, req).pipe(function(results) {
        return Deferred(function() {
          cb(results.results, results.facets);
          return this.resolve(results.results, results.facets);
        });
      });
    };

    Service.prototype.count = function(q, cb) {
      var req;
      if (q.toXML != null) {
        req = {
          query: q.toXML(),
          format: 'jsoncount'
        };
        return this.post(QUERY_RESULTS_PATH, req).pipe(get('count')).done(cb);
      } else {
        return this.query(q).pipe(this.count).done(cb);
      }
    };

    Service.prototype.findById = function(type, id, cb) {
      return this.query({
        from: type,
        select: ['**'],
        where: {
          id: id
        }
      }).pipe(dejoin).pipe(invoke('records')).pipe(get(0)).done(cb);
    };

    Service.prototype.find = function(type, term, cb) {
      return this.query({
        from: type,
        select: ['**'],
        where: [[type, 'LOOKUP', term]]
      }).pipe(dejoin).pipe(invoke('records')).done(cb);
    };

    Service.prototype.whoami = function(cb) {
      var _this = this;
      return this.fetchVersion().pipe(function(v) {
        var fn;
        fn = function(x) {
          return new User(_this, x);
        };
        if (v < 9) {
          return Deferred(function() {
            return this.reject(REQUIRES(9, v));
          });
        } else {
          try {
            return _this.get(WHOAMI_PATH).pipe(get('user')).pipe(fn).done(cb);
          } catch (e) {
            return Deferred(function() {
              return this.reject(e);
            });
          }
        }
      });
    };

    Service.prototype.doPagedRequest = function(q, path, page, format, cb) {
      var req,
        _this = this;
      if (page == null) {
        page = {};
      }
      if (q.toXML != null) {
        req = _.defaults({}, {
          query: q.toXML(),
          format: format
        }, page);
        return this.post(path, req).pipe(get('results')).done(cb);
      } else {
        return this.query(q).pipe(function(query) {
          return _this.doPagedRequest(query, path, page, format, cb);
        });
      }
    };

    Service.prototype.table = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsontable', cb);
    };

    Service.prototype.records = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsonobjects', cb);
    };

    Service.prototype.rows = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'json', cb);
    };

    Service.prototype.tableRows = function(q, page, cb) {
      return this.doPagedRequest(q, TABLE_ROW_PATH, page, 'json', cb);
    };

    Service.prototype.fetchTemplates = function(cb) {
      return this.get(TEMPLATES_PATH).pipe(get('templates')).done(cb);
    };

    Service.prototype.fetchLists = function(cb) {
      return this.findLists('', cb);
    };

    Service.prototype.findLists = function(name, cb) {
      var fn,
        _this = this;
      fn = function(ls) {
        var data, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = ls.length; _i < _len; _i++) {
          data = ls[_i];
          _results.push(new List(data, _this));
        }
        return _results;
      };
      return this.get(LISTS_PATH, {
        name: name
      }).pipe(get('lists')).pipe(fn).done(cb);
    };

    Service.prototype.fetchList = function(name, cb) {
      var _this = this;
      return this.fetchVersion().pipe(function(v) {
        if (v < 13) {
          return _this.fetchLists().pipe(getListFinder(name)).done(cb);
        } else {
          return _this.findLists(name).pipe(get(0)).done(cb);
        }
      });
    };

    Service.prototype.fetchListsContaining = function(opts, cb) {
      var fn,
        _this = this;
      fn = function(xs) {
        var x, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = xs.length; _i < _len; _i++) {
          x = xs[_i];
          _results.push(new List(x, _this));
        }
        return _results;
      };
      return this.get(WITH_OBJ_PATH, opts).pipe(get('lists')).pipe(fn).done(cb);
    };

    Service.prototype.combineLists = function(operation, options, cb) {
      var req;
      req = _.pick(options, 'name', 'description');
      req.tags = options.tags.join(';');
      req.lists = options.lists.join(';');
      return this.get(LIST_OPERATION_PATHS[operation], req).pipe(get('listName')).pipe(this.fetchList).done(cb);
    };

    Service.prototype.merge = function() {
      return this.combineLists.apply(this, ['merge'].concat(__slice.call(arguments)));
    };

    Service.prototype.intersect = function() {
      return this.combineLists.apply(this, ['intersect'].concat(__slice.call(arguments)));
    };

    Service.prototype.diff = function() {
      return this.combineLists.apply(this, ['diff'].concat(__slice.call(arguments)));
    };

    Service.prototype.fetchWidgets = function(cb) {
      return _get_or_fetch.call(this, 'widgets', WIDGETS, WIDGETS_PATH, 'widgets', cb);
    };

    Service.prototype.fetchModel = function(cb) {
      return _get_or_fetch.call(this, 'model', MODELS, MODEL_PATH, 'model').pipe(modeller).pipe(set({
        service: this
      })).done(cb);
    };

    Service.prototype.fetchSummaryFields = function(cb) {
      return _get_or_fetch.call(this, 'summaryFields', SUMMARY_FIELDS, SUMMARYFIELDS_PATH, 'classes', cb);
    };

    Service.prototype.fetchVersion = function(cb) {
      return _get_or_fetch.call(this, 'version', VERSIONS, VERSION_PATH, 'version', cb);
    };

    Service.prototype.query = function(options, cb) {
      var _this = this;
      return $.when(this.fetchModel(), this.fetchSummaryFields()).pipe(function(m, sfs) {
        var args, service;
        args = _.defaults({}, options, {
          model: m,
          summaryFields: sfs
        });
        service = _this;
        return Deferred(function() {
          this.fail(service.errorHandler);
          this.done(cb);
          try {
            return this.resolve(new Query(args, service));
          } catch (e) {
            return this.reject(e);
          }
        });
      });
    };

    Service.prototype.manageUserPreferences = function(method, data) {
      var s;
      s = this;
      return this.fetchVersion().pipe(function(v) {
        if (v >= 11) {
          return s.makeRequest(method, PREF_PATH, data).pipe(get('preferences'));
        } else {
          return Deferred(function() {
            return this.reject(REQUIRES(11, v));
          }).promise();
        }
      });
    };

    return Service;

  })();

  wire_for_node = function() {
    var PESKY_COMMA, blocking, iterReq, streaming;
    PESKY_COMMA = /,\s*$/;
    iterReq = function(format) {
      return function(q, page, cbs) {
        var doThis, onEnd, onErr, req, _ref4;
        if (page == null) {
          page = {};
        }
        if (cbs == null) {
          cbs = [];
        }
        if (!(cbs != null) && !((page.start != null) || (page.size != null))) {
          _ref4 = [{}, page], page = _ref4[0], cbs = _ref4[1];
        }
        if (_.isFunction(cbs)) {
          cbs = [cbs];
        }
        req = _.extend({
          format: format
        }, page, {
          query: q.toXML()
        });
        doThis = cbs[0], onErr = cbs[1], onEnd = cbs[2];
        return this.makeRequest('POST', QUERY_RESULTS_PATH, req, null, true).fail(onErr).done(invoke('each', doThis)).done(invoke('error', onErr)).done(invoke('done', onEnd));
      };
    };
    Service.prototype.rowByRow = iterReq('json');
    Service.prototype.recordByRecord = iterReq('jsonobjects');
    streaming = function(ret, opts) {
      return function(resp) {
        var char0, charZ, containerBuffer, iter, onEnd, onlyDefinedItems, toItem;
        containerBuffer = '';
        char0 = opts.data.format === 'json' ? '[' : '{';
        charZ = opts.data.format === 'json' ? ']' : '}';
        toItem = function(line, idx) {
          var lastChar, parsed;
          try {
            parsed = JSON.parse(line.replace(PESKY_COMMA, ''));
            return parsed;
          } catch (e) {
            containerBuffer += line;
            lastChar = line[line.length - 1];
            if (idx > 0 && (lastChar === ',' || (lastChar === char0 && line[0] === charZ))) {
              iter.emit('error', e, line);
            }
            return void 0;
          }
        };
        onlyDefinedItems = function(item) {
          return item != null;
        };
        onEnd = function() {
          var container;
          try {
            container = JSON.parse(containerBuffer);
            if (container.error) {
              return iter.emit('error', new Error(container.error));
            }
          } catch (e) {
            return iter.emit('error', "Mal-formed JSON response: " + containerBuffer);
          }
        };
        iter = new BufferedResponse(resp, 'utf8').map(toItem).filter(onlyDefinedItems).each(opts.success).error(opts.error).done(onEnd);
        return ret.resolve(iter);
      };
    };
    blocking = function(ret, opts) {
      return function(resp) {
        var containerBuffer;
        containerBuffer = '';
        ret.done(opts.success);
        resp.on('data', function(chunk) {
          return containerBuffer += chunk;
        });
        resp.on('error', function(e) {
          return ret.reject(e);
        });
        return resp.on('end', function() {
          var err, parsed;
          if (/json/.test(opts.data.format)) {
            if ('' === containerBuffer && resp.statusCode === 200) {
              return ret.resolve();
            } else {
              try {
                parsed = JSON.parse(containerBuffer);
                if (err = parsed.error) {
                  return ret.reject(new Error(err));
                } else {
                  return ret.resolve(parsed);
                }
              } catch (e) {
                if (resp.statusCode >= 400) {
                  return ret.reject(new Error(resp.statusCode));
                } else {
                  return ret.reject(new Error("Could not parse response to " + opts.type + " " + opts.url + ": '" + containerBuffer + "' (" + e + ")"));
                }
              }
            }
          } else {
            if (e = containerBuffer.match(/\[Error\] (\d+)(.*)/m)) {
              return ret.reject(new Error(e[2]));
            } else {
              return ret.resolve(containerBuffer);
            }
          }
        });
      };
    };
    return Service.prototype.doReq = function(opts, iter) {
      return Deferred(function() {
        var postdata, req, url, _ref4, _ref5, _ref6;
        this.fail(opts.error);
        this.done(opts.success);
        if (_.isString(opts.data)) {
          postdata = opts.data;
          if ((_ref4 = opts.type) === 'GET' || _ref4 === 'DELETE') {
            return ret.reject("Invalid request. " + opts.type + " requests must not have bodies");
          }
        } else {
          postdata = to_query_string(opts.data);
        }
        url = URL.parse(opts.url, true);
        url.method = opts.type;
        url.port = url.port || 80;
        url.headers = {
          'User-Agent': 'node-http/imjs',
          'Accept': ACCEPT_HEADER[opts.dataType]
        };
        if (((_ref5 = url.method) === 'GET' || _ref5 === 'DELETE') && _.size(opts.data)) {
          url.path += '?' + postdata;
        } else {
          url.headers['Content-Type'] = (opts.contentType || URLENC) + '; charset=UTF-8';
          url.headers['Content-Length'] = postdata.length;
        }
        req = http.request(url, (iter ? streaming : blocking)(this, opts));
        req.on('error', this.reject);
        if ((_ref6 = url.method) === 'POST' || _ref6 === 'PUT') {
          req.write(postdata);
        }
        return req.end();
      });
    };
  };

  wire_for_browser = function() {
    var iterReq, mapping, wrapCbs;
    if (typeof XDomainRequest !== "undefined" && XDomainRequest !== null) {
      mapping = {
        PUT: 'POST',
        DELETE: 'GET'
      };
      Service.prototype.getEffectiveMethod = function(x) {
        return mapping[x];
      };
      Service.prototype.supports = function(m) {
        return mapping[m] === m;
      };
    }
    wrapCbs = function(cbs) {
      var atEnd, doThis, err;
      if (_.isArray(cbs)) {
        doThis = cbs[0], err = cbs[1], atEnd = cbs[2];
        return [
          (function(rows) {
            return _.each(rows, doThis);
          }), err, atEnd
        ];
      } else {
        return [
          function(rows) {
            return _.each(rows, cbs);
          }
        ];
      }
    };
    iterReq = function(format) {
      return function(q, page, cbs) {
        var doThis, fail, onEnd, req, _cbs, _ref4;
        if (page == null) {
          page = {};
        }
        if (cbs == null) {
          cbs = [];
        }
        if (!(cbs != null) && !((page.start != null) || (page.size != null))) {
          _ref4 = [{}, page], page = _ref4[0], cbs = _ref4[1];
        }
        _cbs = wrapCbs(cbs);
        req = _.extend({
          format: format
        }, page, {
          query: q.toXML()
        });
        doThis = _cbs[0], fail = _cbs[1], onEnd = _cbs[2];
        return this.post(QUERY_RESULTS_PATH, req, _cbs).done(onEnd);
      };
    };
    Service.prototype.rowByRow = iterReq('json');
    Service.prototype.recordByRecord = iterReq('jsonobjects');
    return Service.prototype.doReq = function(opts) {
      var errBack;
      errBack = opts.error || this.errorHandler;
      opts.error = _.compose(errBack, ERROR_PIPE);
      return jQuery.ajax(opts).pipe(CHECKING_PIPE).fail(errBack);
    };
  };

  if (IS_NODE) {
    wire_for_node();
  } else {
    wire_for_browser();
  }

  Service.prototype.eachRow = Service.prototype.rowByRow;

  Service.prototype.eachRecord = Service.prototype.recordByRecord;

  Service.flushCaches = function() {
    MODELS = {};
    VERSIONS = {};
    SUMMARY_FIELDS = {};
    return WIDGETS = {};
  };

  Service.connect = function(opts) {
    return new Service(opts);
  };

  intermine.Service = Service;

  if (IS_NODE) {
    intermine.Model = Model;
    intermine.Query = Query;
    intermine.List = List;
    intermine.User = User;
  }

}).call(this);
