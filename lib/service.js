// Generated by CoffeeScript 1.3.3
(function() {
  var $, ACCEPT_HEADER, BufferedResponse, CHECKING_PIPE, DEFAULT_ERROR_HANDLER, DEFAULT_PROTOCOL, Deferred, ENRICHMENT_PATH, ERROR_PIPE, EventEmitter, HAS_PROTOCOL, HAS_SUFFIX, IDENTITY, IS_NODE, LISTS_PATH, LIST_OPERATION_PATHS, List, MODELS, MODEL_PATH, Model, PREF_PATH, QUERY_RESULTS_PATH, QUICKSEARCH_PATH, Query, REQUIRES, REQUIRES_VERSION, SUFFIX, SUMMARYFIELDS_PATH, SUMMARY_FIELDS, Service, TABLE_ROW_PATH, TEMPLATES_PATH, URL, URLENC, User, VERSIONS, VERSION_PATH, WHOAMI_PATH, WIDGETS, WIDGETS_PATH, WITH_OBJ_PATH, dejoin, error, funcutils, get, getListFinder, http, intermine, invoke, jQuery, qs, set, success, to_query_string, wire_for_browser, wire_for_node, _, __root__, _get_or_fetch, _ref, _ref1, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  IS_NODE = typeof exports !== 'undefined';

  __root__ = typeof exports !== "undefined" && exports !== null ? exports : this;

  ACCEPT_HEADER = {
    "json": "application/json",
    "jsonobjects": "application/json;type=objects",
    "jsontable": "application/json;type=table",
    "jsonrows": "application/json;type=rows",
    "jsoncount": "application/json;type=count",
    "jsonp": "application/javascript",
    "jsonpobjects": "application/javascript;type=objects",
    "jsonptable": "application/javascript;type=table",
    "jsonprows": "application/javascript;type=rows",
    "jsonpcount": "application/javascript;type=count"
  };

  URLENC = "application/x-www-form-urlencoded";

  if (IS_NODE) {
    _ = require('underscore')._;
    Deferred = ($ = require('underscore.deferred')).Deferred;
    http = require('http');
    URL = require('url');
    qs = require('querystring');
    Model = require('./model').Model;
    Query = require('./query').Query;
    List = require('./lists').List;
    User = require('./user').User;
    funcutils = require('./util');
    EventEmitter = require('events').EventEmitter;
    BufferedResponse = require('buffered-response').BufferedResponse;
    to_query_string = qs.stringify;
    intermine = exports;
  } else {
    _ = __root__._, jQuery = __root__.jQuery, intermine = __root__.intermine;
    Deferred = ($ = jQuery).Deferred;
    to_query_string = jQuery.param;
    Model = intermine.Model, Query = intermine.Query, List = intermine.List, User = intermine.User, funcutils = intermine.funcutils;
    (function() {
      var converters, format, header;
      converters = {};
      for (format in ACCEPT_HEADER) {
        header = ACCEPT_HEADER[format];
        converters["text " + format] = jQuery.parseJSON;
      }
      return jQuery.ajaxSetup({
        accepts: ACCEPT_HEADER,
        contents: {
          json: /json/
        },
        converters: converters
      });
    })();
  }

  get = funcutils.get, set = funcutils.set, invoke = funcutils.invoke, success = funcutils.success, error = funcutils.error;

  VERSIONS = {};

  MODELS = {};

  SUMMARY_FIELDS = {};

  WIDGETS = {};

  DEFAULT_PROTOCOL = "http://";

  VERSION_PATH = "version";

  TEMPLATES_PATH = "templates";

  LISTS_PATH = "lists";

  MODEL_PATH = "model";

  SUMMARYFIELDS_PATH = "summaryfields";

  QUERY_RESULTS_PATH = "query/results";

  QUICKSEARCH_PATH = "search";

  WIDGETS_PATH = "widgets";

  ENRICHMENT_PATH = "list/enrichment";

  WITH_OBJ_PATH = "listswithobject";

  LIST_OPERATION_PATHS = {
    merge: "lists/union",
    intersect: "lists/intersect",
    diff: "lists/diff"
  };

  WHOAMI_PATH = "user/whoami";

  TABLE_ROW_PATH = QUERY_RESULTS_PATH + '/tablerows';

  PREF_PATH = 'user/preferences';

  REQUIRES = function(required, got) {
    return "This service requires a service at version " + required + " or above. This one is at " + got;
  };

  IDENTITY = function(x) {
    return x;
  };

  HAS_PROTOCOL = /^https?:\/\//i;

  HAS_SUFFIX = /service\/?$/i;

  SUFFIX = "/service/";

  DEFAULT_ERROR_HANDLER = function(e) {
    var _ref;
    if (IS_NODE && (e.stack != null)) {
      return console.error(e.stack);
    } else {
      if (typeof console !== "undefined" && console !== null) {
        return (_ref = console.error || console.log) != null ? _ref.apply(console, arguments) : void 0;
      }
    }
  };

  ERROR_PIPE = function(xhr, textStatus, e) {
    try {
      return JSON.parse(xhr.responseText).error;
    } catch (e) {
      return textStatus;
    }
  };

  CHECKING_PIPE = function(response) {
    return Deferred(function() {
      if (response.wasSuccessful) {
        return this.resolve(response);
      } else {
        return this.reject(response.error, response);
      }
    });
  };

  dejoin = function(q) {
    var parts, view, _i, _len, _ref;
    _ref = q.views;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      view = _ref[_i];
      parts = view.split('.');
      if (parts.length > 2) {
        q.addJoin(parts.slice(1, -1).join('.'));
      }
    }
    return q;
  };

  _get_or_fetch = function(propName, store, path, key, cb) {
    var prop, value, _ref,
      _this = this;
    prop = (_ref = this[propName]) != null ? _ref : this[propName] = this.useCache && (value = store[this.root]) ? success(value) : this.get(path).pipe(get(key)).done(function(x) {
      return store[_this.root] = x;
    });
    return prop.done(cb);
  };

  REQUIRES_VERSION = function(s, n, f) {
    return s.fetchVersion().pipe(function(v) {
      if (v >= n) {
        return f();
      } else {
        return error(REQUIRES(n, v));
      }
    });
  };

  getListFinder = function(name) {
    return function(lists) {
      return Deferred(function() {
        var list;
        if (list = _.find(lists, function(l) {
          return l.name === name;
        })) {
          return this.resolve(list);
        } else {
          return this.reject("List \"" + name + "\" not found among: " + (lists.map(get('name'))));
        }
      });
    };
  };

  Service = (function() {

    function Service(_arg) {
      var loc, noCache, _ref, _ref1,
        _this = this;
      this.root = _arg.root, this.token = _arg.token, this.errorHandler = _arg.errorHandler, this.DEBUG = _arg.DEBUG, this.help = _arg.help, noCache = _arg.noCache;
      this.query = __bind(this.query, this);

      this.fetchListsContaining = __bind(this.fetchListsContaining, this);

      this.fetchList = __bind(this.fetchList, this);

      this.fetchTemplates = __bind(this.fetchTemplates, this);

      this.tableRows = __bind(this.tableRows, this);

      this.rows = __bind(this.rows, this);

      this.records = __bind(this.records, this);

      this.table = __bind(this.table, this);

      this.findById = __bind(this.findById, this);

      this.count = __bind(this.count, this);

      if (this.root == null) {
        throw new Error("No service root provided. This is required");
      }
      if (!HAS_PROTOCOL.test(this.root)) {
        this.root = DEFAULT_PROTOCOL + this.root;
      }
      if (!HAS_SUFFIX.test(this.root)) {
        this.root = this.root + SUFFIX;
      }
      this.root = this.root.replace(/ics$/, "ice/");
      if ((_ref = this.errorHandler) == null) {
        this.errorHandler = DEFAULT_ERROR_HANDLER;
      }
      if ((_ref1 = this.help) == null) {
        this.help = 'no.help.available@dev.null';
      }
      this.useCache = !noCache;
      loc = IS_NODE ? '' : location.protocol + '//' + location.host;
      this.getFormat = function(intended) {
        if (intended == null) {
          intended = 'json';
        }
        if (!/jsonp/.test(intended)) {
          if (!(IS_NODE || jQuery.support.cors)) {
            if (loc.substring(0, _this.root.length) !== _this.root) {
              return intended.replace('json', 'jsonp');
            }
          }
        }
        return intended;
      };
    }

    Service.prototype.post = function(path, data) {
      if (data == null) {
        data = {};
      }
      return this.makeRequest('POST', path, data);
    };

    Service.prototype.get = function(path, data) {
      return this.makeRequest('GET', path, data);
    };

    Service.prototype.makeRequest = function(method, path, data, cb, indiv) {
      var errBack, opts, url, _ref;
      if (method == null) {
        method = 'GET';
      }
      if (path == null) {
        path = '';
      }
      if (data == null) {
        data = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (indiv == null) {
        indiv = false;
      }
      if (_.isArray(cb)) {
        _ref = cb, cb = _ref[0], errBack = _ref[1];
      }
      if (_.isArray(data)) {
        data = _.foldl(data, (function(m, _arg) {
          var k, v;
          k = _arg[0], v = _arg[1];
          m[k] = v;
          return m;
        }), {});
      }
      url = this.root + path;
      if (errBack == null) {
        errBack = this.errorHandler;
      }
      if (this.token) {
        data.token = this.token;
      }
      data.format = this.getFormat(data.format);
      if (/jsonp/.test(data.format)) {
        data.method = method;
        method = 'GET';
        url += '?callback=?';
      }
      if (!this.supports(method)) {
        data.method = method;
        method = this.getEffectiveMethod(method);
      }
      if (method === 'DELETE') {
        url += '?' + to_query_string(data);
      }
      opts = {
        data: data,
        dataType: data.format,
        success: cb,
        error: errBack,
        url: url,
        type: method
      };
      return this.doReq(opts, indiv);
    };

    Service.prototype.supports = function() {
      return true;
    };

    Service.prototype.getEffectiveMethod = function(x) {
      return x;
    };

    Service.prototype.enrichment = function(opts, cb) {
      var _this = this;
      return REQUIRES_VERSION(this, 8, function() {
        return _this.get(ENRICHMENT_PATH, _.defaults({}, opts, {
          maxp: 0.05
        })).pipe(get('results')).done(cb);
      });
    };

    Service.prototype.search = function(options, cb) {
      var _this = this;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      return REQUIRES_VERSION(this, 9, function() {
        var k, parse, req, v, _ref, _ref1;
        if (_.isFunction(options)) {
          _ref = [options, {}], cb = _ref[0], options = _ref[1];
        }
        if (_.isString(options)) {
          options = {
            q: options
          };
        }
        req = _.defaults({}, options, {
          q: ''
        });
        delete req.facets;
        if (options.facets) {
          _ref1 = options.facets;
          for (k in _ref1) {
            v = _ref1[k];
            req["facet_" + k] = v;
          }
        }
        parse = function(response) {
          return success(response.results, response.facets);
        };
        return _this.post(QUICKSEARCH_PATH, req).pipe(parse).done(cb);
      });
    };

    Service.prototype.count = function(q, cb) {
      var req;
      if (q.toXML != null) {
        req = {
          query: q.toXML(),
          format: 'jsoncount'
        };
        return this.post(QUERY_RESULTS_PATH, req).pipe(get('count')).done(cb);
      } else {
        return this.query(q).pipe(this.count).done(cb);
      }
    };

    Service.prototype.findById = function(type, id, cb) {
      return this.query({
        from: type,
        select: ['**'],
        where: {
          id: id
        }
      }).pipe(dejoin).pipe(invoke('records')).pipe(get(0)).done(cb);
    };

    Service.prototype.find = function(type, term, cb) {
      return this.query({
        from: type,
        select: ['**'],
        where: [[type, 'LOOKUP', term]]
      }).pipe(dejoin).pipe(invoke('records')).done(cb);
    };

    Service.prototype.whoami = function(cb) {
      var _this = this;
      return REQUIRES_VERSION(this, 9, function() {
        return _this.get(WHOAMI_PATH).pipe(get('user')).pipe(function(x) {
          return new User(_this, x);
        }).done(cb);
      });
    };

    Service.prototype.doPagedRequest = function(q, path, page, format, cb) {
      var req,
        _this = this;
      if (page == null) {
        page = {};
      }
      if (q.toXML != null) {
        req = _.defaults({}, {
          query: q.toXML(),
          format: format
        }, page);
        return this.post(path, req).pipe(get('results')).done(cb);
      } else {
        return this.query(q).pipe(function(query) {
          return _this.doPagedRequest(query, path, page, format, cb);
        });
      }
    };

    Service.prototype.table = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsontable', cb);
    };

    Service.prototype.records = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsonobjects', cb);
    };

    Service.prototype.rows = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'json', cb);
    };

    Service.prototype.tableRows = function(q, page, cb) {
      return this.doPagedRequest(q, TABLE_ROW_PATH, page, 'json', cb);
    };

    Service.prototype.fetchTemplates = function(cb) {
      return this.get(TEMPLATES_PATH).pipe(get('templates')).done(cb);
    };

    Service.prototype.fetchLists = function(cb) {
      return this.findLists('', cb);
    };

    Service.prototype.findLists = function(name, cb) {
      var fn,
        _this = this;
      fn = function(ls) {
        var data, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = ls.length; _i < _len; _i++) {
          data = ls[_i];
          _results.push(new List(data, _this));
        }
        return _results;
      };
      return this.get(LISTS_PATH, {
        name: name
      }).pipe(get('lists')).pipe(fn).done(cb);
    };

    Service.prototype.fetchList = function(name, cb) {
      var _this = this;
      return this.fetchVersion().pipe(function(v) {
        if (v < 13) {
          return _this.fetchLists().pipe(getListFinder(name)).done(cb);
        } else {
          return _this.findLists(name).pipe(get(0)).done(cb);
        }
      });
    };

    Service.prototype.fetchListsContaining = function(opts, cb) {
      var fn,
        _this = this;
      fn = function(xs) {
        var x, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = xs.length; _i < _len; _i++) {
          x = xs[_i];
          _results.push(new List(x, _this));
        }
        return _results;
      };
      return this.get(WITH_OBJ_PATH, opts).pipe(get('lists')).pipe(fn).done(cb);
    };

    Service.prototype.combineLists = function(operation, options, cb) {
      var req;
      req = _.pick(options, 'name', 'description');
      req.tags = options.tags.join(';');
      req.lists = options.lists.join(';');
      return this.get(LIST_OPERATION_PATHS[operation], req).pipe(get('listName')).pipe(this.fetchList).done(cb);
    };

    Service.prototype.merge = function() {
      return this.combineLists.apply(this, ['merge'].concat(__slice.call(arguments)));
    };

    Service.prototype.intersect = function() {
      return this.combineLists.apply(this, ['intersect'].concat(__slice.call(arguments)));
    };

    Service.prototype.diff = function() {
      return this.combineLists.apply(this, ['diff'].concat(__slice.call(arguments)));
    };

    Service.prototype.fetchWidgets = function(cb) {
      var _this = this;
      return REQUIRES_VERSION(this, 8, function() {
        return _get_or_fetch.call(_this, 'widgets', WIDGETS, WIDGETS_PATH, 'widgets', cb);
      });
    };

    Service.prototype.fetchModel = function(cb) {
      return _get_or_fetch.call(this, 'model', MODELS, MODEL_PATH, 'model').pipe(Model.load).pipe(set({
        service: this
      })).done(cb);
    };

    Service.prototype.fetchSummaryFields = function(cb) {
      return _get_or_fetch.call(this, 'summaryFields', SUMMARY_FIELDS, SUMMARYFIELDS_PATH, 'classes', cb);
    };

    Service.prototype.fetchVersion = function(cb) {
      return _get_or_fetch.call(this, 'version', VERSIONS, VERSION_PATH, 'version', cb);
    };

    Service.prototype.query = function(options, cb) {
      var _this = this;
      return $.when(this.fetchModel(), this.fetchSummaryFields()).pipe(function(m, sfs) {
        var args, service;
        args = _.defaults({}, options, {
          model: m,
          summaryFields: sfs
        });
        service = _this;
        return Deferred(function() {
          this.fail(service.errorHandler);
          this.done(cb);
          try {
            return this.resolve(new Query(args, service));
          } catch (e) {
            return this.reject(e);
          }
        });
      });
    };

    Service.prototype.manageUserPreferences = function(method, data) {
      var _this = this;
      return REQUIRES_VERSION(this, 11, function() {
        return _this.makeRequest(method, PREF_PATH, data).pipe(get('preferences'));
      });
    };

    return Service;

  })();

  wire_for_node = function() {
    var PESKY_COMMA, blocking, iterReq, streaming;
    PESKY_COMMA = /,\s*$/;
    iterReq = function(format) {
      return function(q, page, cbs) {
        var doThis, onEnd, onErr, req, _ref;
        if (page == null) {
          page = {};
        }
        if (cbs == null) {
          cbs = [];
        }
        if (!(cbs != null) && !((page.start != null) || (page.size != null))) {
          _ref = [{}, page], page = _ref[0], cbs = _ref[1];
        }
        if (_.isFunction(cbs)) {
          cbs = [cbs];
        }
        req = _.extend({
          format: format
        }, page, {
          query: q.toXML()
        });
        doThis = cbs[0], onErr = cbs[1], onEnd = cbs[2];
        return this.makeRequest('POST', QUERY_RESULTS_PATH, req, null, true).fail(onErr).done(invoke('each', doThis)).done(invoke('error', onErr)).done(invoke('done', onEnd));
      };
    };
    Service.prototype.rowByRow = iterReq('json');
    Service.prototype.recordByRecord = iterReq('jsonobjects');
    streaming = function(ret, opts) {
      return function(resp) {
        var char0, charZ, containerBuffer, iter, onEnd, onlyDefinedItems, toItem;
        containerBuffer = '';
        char0 = opts.data.format === 'json' ? '[' : '{';
        charZ = opts.data.format === 'json' ? ']' : '}';
        toItem = function(line, idx) {
          var lastChar, parsed;
          try {
            parsed = JSON.parse(line.replace(PESKY_COMMA, ''));
            return parsed;
          } catch (e) {
            containerBuffer += line;
            lastChar = line[line.length - 1];
            if (idx > 0 && (lastChar === ',' || (lastChar === char0 && line[0] === charZ))) {
              iter.emit('error', e, line);
            }
            return void 0;
          }
        };
        onlyDefinedItems = function(item) {
          return item != null;
        };
        onEnd = function() {
          var container;
          try {
            container = JSON.parse(containerBuffer);
            if (container.error) {
              return iter.emit('error', new Error(container.error));
            }
          } catch (e) {
            return iter.emit('error', "Mal-formed JSON response: " + containerBuffer);
          }
        };
        iter = new BufferedResponse(resp, 'utf8').map(toItem).filter(onlyDefinedItems).each(opts.success).error(opts.error).done(onEnd);
        return ret.resolve(iter);
      };
    };
    blocking = function(ret, opts) {
      return function(resp) {
        var containerBuffer;
        containerBuffer = '';
        ret.done(opts.success);
        resp.on('data', function(chunk) {
          return containerBuffer += chunk;
        });
        resp.on('error', function(e) {
          return ret.reject(e);
        });
        return resp.on('end', function() {
          var err, parsed;
          if (/json/.test(opts.data.format)) {
            if ('' === containerBuffer && resp.statusCode === 200) {
              return ret.resolve();
            } else {
              try {
                parsed = JSON.parse(containerBuffer);
                if (err = parsed.error) {
                  return ret.reject(new Error(err));
                } else {
                  return ret.resolve(parsed);
                }
              } catch (e) {
                if (resp.statusCode >= 400) {
                  return ret.reject(new Error(resp.statusCode));
                } else {
                  return ret.reject(new Error("Could not parse response to " + opts.type + " " + opts.url + ": '" + containerBuffer + "' (" + e + ")"));
                }
              }
            }
          } else {
            if (e = containerBuffer.match(/\[Error\] (\d+)(.*)/m)) {
              return ret.reject(new Error(e[2]));
            } else {
              return ret.resolve(containerBuffer);
            }
          }
        });
      };
    };
    return Service.prototype.doReq = function(opts, iter) {
      return Deferred(function() {
        var postdata, req, url, _ref, _ref1, _ref2;
        this.fail(opts.error);
        this.done(opts.success);
        if (_.isString(opts.data)) {
          postdata = opts.data;
          if ((_ref = opts.type) === 'GET' || _ref === 'DELETE') {
            return ret.reject("Invalid request. " + opts.type + " requests must not have bodies");
          }
        } else {
          postdata = to_query_string(opts.data);
        }
        url = URL.parse(opts.url, true);
        url.method = opts.type;
        url.port = url.port || 80;
        url.headers = {
          'User-Agent': 'node-http/imjs',
          'Accept': ACCEPT_HEADER[opts.dataType]
        };
        if (((_ref1 = url.method) === 'GET' || _ref1 === 'DELETE') && _.size(opts.data)) {
          url.path += '?' + postdata;
        } else {
          url.headers['Content-Type'] = (opts.contentType || URLENC) + '; charset=UTF-8';
          url.headers['Content-Length'] = postdata.length;
        }
        req = http.request(url, (iter ? streaming : blocking)(this, opts));
        req.on('error', this.reject);
        if ((_ref2 = url.method) === 'POST' || _ref2 === 'PUT') {
          req.write(postdata);
        }
        return req.end();
      });
    };
  };

  wire_for_browser = function() {
    var iterReq, mapping, wrapCbs;
    if (typeof XDomainRequest !== "undefined" && XDomainRequest !== null) {
      mapping = {
        PUT: 'POST',
        DELETE: 'GET'
      };
      Service.prototype.getEffectiveMethod = function(x) {
        return mapping[x];
      };
      Service.prototype.supports = function(m) {
        return mapping[m] === m;
      };
    }
    wrapCbs = function(cbs) {
      var atEnd, doThis, err;
      if (_.isArray(cbs)) {
        doThis = cbs[0], err = cbs[1], atEnd = cbs[2];
        return [
          (function(rows) {
            return _.each(rows, doThis);
          }), err, atEnd
        ];
      } else {
        return [
          function(rows) {
            return _.each(rows, cbs);
          }
        ];
      }
    };
    iterReq = function(format) {
      return function(q, page, cbs) {
        var doThis, fail, onEnd, req, _cbs, _ref;
        if (page == null) {
          page = {};
        }
        if (cbs == null) {
          cbs = [];
        }
        if (!(cbs != null) && !((page.start != null) || (page.size != null))) {
          _ref = [{}, page], page = _ref[0], cbs = _ref[1];
        }
        _cbs = wrapCbs(cbs);
        req = _.extend({
          format: format
        }, page, {
          query: q.toXML()
        });
        doThis = _cbs[0], fail = _cbs[1], onEnd = _cbs[2];
        return this.post(QUERY_RESULTS_PATH, req, _cbs).done(onEnd);
      };
    };
    Service.prototype.rowByRow = iterReq('json');
    Service.prototype.recordByRecord = iterReq('jsonobjects');
    return Service.prototype.doReq = function(opts) {
      var errBack;
      errBack = opts.error || this.errorHandler;
      opts.error = _.compose(errBack, ERROR_PIPE);
      return jQuery.ajax(opts).pipe(CHECKING_PIPE).fail(errBack);
    };
  };

  if (IS_NODE) {
    wire_for_node();
  } else {
    wire_for_browser();
  }

  Service.prototype.eachRow = Service.prototype.rowByRow;

  Service.prototype.eachRecord = Service.prototype.recordByRecord;

  Service.flushCaches = function() {
    MODELS = {};
    VERSIONS = {};
    SUMMARY_FIELDS = {};
    return WIDGETS = {};
  };

  Service.connect = function(opts) {
    return new Service(opts);
  };

  intermine.Service = Service;

  if ((_ref = intermine.Model) == null) {
    intermine.Model = Model;
  }

  if ((_ref1 = intermine.Query) == null) {
    intermine.Query = Query;
  }

  if ((_ref2 = intermine.List) == null) {
    intermine.List = List;
  }

  if ((_ref3 = intermine.User) == null) {
    intermine.User = User;
  }

}).call(this);
