// Generated by CoffeeScript 1.3.3
(function() {
  var $, Deferred, IS_NODE, NAMES, PARSED, PathInfo, any, concatMap, copy, get, intermine, makeKey, set, _, __root__, _ref, _ref1, _ref2,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  IS_NODE = typeof exports !== 'undefined';

  __root__ = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (IS_NODE) {
    intermine = exports;
    _ = require('underscore')._;
    Deferred = ($ = require('underscore.deferred')).Deferred;
    _ref = require('./shiv'), concatMap = _ref.concatMap, get = _ref.get, any = _ref.any, set = _ref.set, copy = _ref.copy;
  } else {
    _ = __root__._;
    Deferred = ($ = __root__.jQuery).Deferred;
    intermine = ((_ref1 = __root__.intermine) != null ? _ref1 : __root__.intermine = {});
    _ref2 = intermine.funcutils, concatMap = _ref2.concatMap, get = _ref2.get, any = _ref2.any, set = _ref2.set, copy = _ref2.copy;
  }

  NAMES = {};

  PARSED = {};

  makeKey = function(model, path, subclasses) {
    var k, v, _ref3;
    return "" + (model != null ? model.name : void 0) + "|" + (model != null ? (_ref3 = model.service) != null ? _ref3.root : void 0 : void 0) + "|" + path + ":" + ((function() {
      var _results;
      _results = [];
      for (k in subclasses) {
        v = subclasses[k];
        _results.push("" + k + "=" + v);
      }
      return _results;
    })());
  };

  PathInfo = (function() {

    function PathInfo(_arg) {
      var _ref3;
      this.root = _arg.root, this.model = _arg.model, this.descriptors = _arg.descriptors, this.subclasses = _arg.subclasses, this.displayName = _arg.displayName, this.ident = _arg.ident;
      this.end = _.last(this.descriptors);
      if ((_ref3 = this.ident) == null) {
        this.ident = makeKey(this.model, this, this.subclasses);
      }
    }

    PathInfo.prototype.isRoot = function() {
      return this.descriptors.length === 0;
    };

    PathInfo.prototype.isAttribute = function() {
      return (this.end != null) && !(this.end.referencedType != null);
    };

    PathInfo.prototype.isClass = function() {
      return this.isRoot() || (this.end.referencedType != null);
    };

    PathInfo.prototype.isReference = function() {
      var _ref3;
      return ((_ref3 = this.end) != null ? _ref3.referencedType : void 0) != null;
    };

    PathInfo.prototype.isCollection = function() {
      var _ref3;
      return (_ref3 = this.end) != null ? _ref3.isCollection : void 0;
    };

    PathInfo.prototype.containsCollection = function() {
      return any(this.descriptors, function(x) {
        return x.isCollection;
      });
    };

    PathInfo.prototype.getEndClass = function() {
      var _ref3;
      return this.model.classes[this.subclasses[this.toString()] || ((_ref3 = this.end) != null ? _ref3.referencedType : void 0)] || this.root;
    };

    PathInfo.prototype.getParent = function() {
      var data;
      if (this.isRoot()) {
        throw new Error("Root paths do not have parents");
      }
      data = {
        root: this.root,
        model: this.model,
        descriptors: _.initial(this.descriptors),
        subclasses: this.subclasses
      };
      return new PathInfo(data);
    };

    PathInfo.prototype.append = function(attr) {
      var data, fld;
      if (this.isAttribute()) {
        throw new Error("" + this + " is an attribute.");
      }
      fld = _.isString(attr) ? this.getType().fields[attr] : attr;
      if (fld == null) {
        throw new Error("" + attr + " is not a field of " + (this.getType()));
      }
      data = {
        root: this.root,
        model: this.model,
        descriptors: this.descriptors.concat(fld),
        subclasses: this.subclasses
      };
      return new PathInfo(data);
    };

    PathInfo.prototype.isa = function(clazz) {
      var name, type;
      if (this.isAttribute()) {
        return this.getType() === clazz;
      } else {
        name = clazz.name ? clazz.name : '' + clazz;
        type = this.getType();
        return (name === type.name) || (__indexOf.call(this.model.getAncestorsOf(type), name) >= 0);
      }
    };

    PathInfo.prototype.getDisplayName = function(cb) {
      var cached, params, path, _ref3,
        _this = this;
      if ((_ref3 = this.namePromise) == null) {
        this.namePromise = (cached = this.displayName || NAMES[this.ident]) ? Deferred().resolve(cached).promise() : !(this.model.service != null) ? Deferred().reject(new Error("No service")).promise() : (path = 'model' + (concatMap(function(d) {
          return '/' + d.name;
        }))(this.allDescriptors()), params = (set({
          format: 'json'
        }))(copy(this.subclasses)), this.model.service.get(path, params).then(get('display')).done(function(n) {
          var _name, _ref4;
          return (_ref4 = NAMES[_name = _this.ident]) != null ? _ref4 : NAMES[_name] = n;
        }));
      }
      return this.namePromise.done(cb);
    };

    PathInfo.prototype.getChildNodes = function() {
      var fld, _ref3, _ref4, _results;
      _ref4 = ((_ref3 = this.getEndClass()) != null ? _ref3.fields : void 0) || {};
      _results = [];
      for (_ in _ref4) {
        fld = _ref4[_];
        _results.push(this.append(fld));
      }
      return _results;
    };

    PathInfo.prototype.allDescriptors = function() {
      return [this.root].concat(this.descriptors);
    };

    PathInfo.prototype.toString = function() {
      return this.allDescriptors().map(get('name')).join('.');
    };

    PathInfo.prototype.getType = function() {
      var _ref3, _ref4;
      return ((_ref3 = this.end) != null ? (_ref4 = _ref3.type) != null ? _ref4.replace(/java\.lang\./, '') : void 0 : void 0) || this.getEndClass();
    };

    return PathInfo;

  })();

  PathInfo.prototype.toPathString = PathInfo.prototype.toString;

  PathInfo.parse = function(model, path, subclasses) {
    var cached, cd, descriptors, fld, ident, keyPath, part, parts, root;
    if (subclasses == null) {
      subclasses = {};
    }
    ident = makeKey(model, path, subclasses);
    if (cached = PARSED[ident]) {
      return cached;
    }
    parts = path.split('.');
    root = cd = model.classes[parts.shift()];
    keyPath = root.name;
    descriptors = (function() {
      var _i, _len, _ref3, _results;
      _results = [];
      for (_i = 0, _len = parts.length; _i < _len; _i++) {
        part = parts[_i];
        fld = (cd != null ? cd.fields[part] : void 0) || ((_ref3 = (cd = model.classes[subclasses[keyPath]])) != null ? _ref3.fields[part] : void 0);
        if (!fld) {
          throw new Error("Could not find " + part + " in " + cd + " when parsing " + path);
        }
        keyPath += "." + part;
        cd = model.classes[fld.type || fld.referencedType];
        _results.push(fld);
      }
      return _results;
    })();
    return PARSED[ident] = new PathInfo({
      root: root,
      model: model,
      descriptors: descriptors,
      subclasses: subclasses,
      ident: ident
    });
  };

  PathInfo.flushCache = function() {
    PARSED = {};
    return NAMES = {};
  };

  exports.PathInfo = PathInfo;

}).call(this);
