// Generated by CoffeeScript 1.3.3
(function() {
  var $, Deferred, IS_NODE, NAMES, PARSED, PathInfo, any, concatMap, copy, error, get, intermine, makeKey, set, success, _, __root__, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  IS_NODE = typeof exports !== 'undefined';

  __root__ = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (IS_NODE) {
    intermine = __root__;
    _ = require('underscore')._;
    Deferred = ($ = require('underscore.deferred')).Deferred;
    _ref = require('./util'), concatMap = _ref.concatMap, get = _ref.get, any = _ref.any, set = _ref.set, copy = _ref.copy, success = _ref.success, error = _ref.error;
  } else {
    _ = __root__._;
    Deferred = ($ = __root__.jQuery).Deferred;
    intermine = __root__.intermine;
    _ref1 = intermine.funcutils, concatMap = _ref1.concatMap, get = _ref1.get, any = _ref1.any, set = _ref1.set, copy = _ref1.copy, success = _ref1.success, error = _ref1.error;
  }

  NAMES = {};

  PARSED = {};

  makeKey = function(model, path, subclasses) {
    var k, v, _ref2;
    return "" + (model != null ? model.name : void 0) + "|" + (model != null ? (_ref2 = model.service) != null ? _ref2.root : void 0 : void 0) + "|" + path + ":" + ((function() {
      var _results;
      _results = [];
      for (k in subclasses) {
        v = subclasses[k];
        _results.push("" + k + "=" + v);
      }
      return _results;
    })());
  };

  PathInfo = (function() {

    function PathInfo(_arg) {
      var _ref2;
      this.root = _arg.root, this.model = _arg.model, this.descriptors = _arg.descriptors, this.subclasses = _arg.subclasses, this.displayName = _arg.displayName, this.ident = _arg.ident;
      this.end = _.last(this.descriptors);
      if ((_ref2 = this.ident) == null) {
        this.ident = makeKey(this.model, this, this.subclasses);
      }
    }

    PathInfo.prototype.isRoot = function() {
      return this.descriptors.length === 0;
    };

    PathInfo.prototype.isAttribute = function() {
      return (this.end != null) && !(this.end.referencedType != null);
    };

    PathInfo.prototype.isClass = function() {
      return this.isRoot() || (this.end.referencedType != null);
    };

    PathInfo.prototype.isReference = function() {
      var _ref2;
      return ((_ref2 = this.end) != null ? _ref2.referencedType : void 0) != null;
    };

    PathInfo.prototype.isCollection = function() {
      var _ref2;
      return (_ref2 = this.end) != null ? _ref2.isCollection : void 0;
    };

    PathInfo.prototype.containsCollection = function() {
      return any(this.descriptors, function(x) {
        return x.isCollection;
      });
    };

    PathInfo.prototype.getEndClass = function() {
      var _ref2;
      return this.model.classes[this.subclasses[this.toString()] || ((_ref2 = this.end) != null ? _ref2.referencedType : void 0)] || this.root;
    };

    PathInfo.prototype.getParent = function() {
      var data;
      if (this.isRoot()) {
        throw new Error("Root paths do not have parents");
      }
      data = {
        root: this.root,
        model: this.model,
        descriptors: _.initial(this.descriptors),
        subclasses: this.subclasses
      };
      return new PathInfo(data);
    };

    PathInfo.prototype.append = function(attr) {
      var data, fld;
      if (this.isAttribute()) {
        throw new Error("" + this + " is an attribute.");
      }
      fld = _.isString(attr) ? this.getType().fields[attr] : attr;
      if (fld == null) {
        throw new Error("" + attr + " is not a field of " + (this.getType()));
      }
      data = {
        root: this.root,
        model: this.model,
        descriptors: this.descriptors.concat(fld),
        subclasses: this.subclasses
      };
      return new PathInfo(data);
    };

    PathInfo.prototype.isa = function(clazz) {
      var name, type;
      if (this.isAttribute()) {
        return this.getType() === clazz;
      } else {
        name = clazz.name ? clazz.name : '' + clazz;
        type = this.getType();
        return (name === type.name) || (__indexOf.call(this.model.getAncestorsOf(type), name) >= 0);
      }
    };

    PathInfo.prototype.getDisplayName = function(cb) {
      var cached, params, path, _ref2,
        _this = this;
      if ((_ref2 = this.namePromise) == null) {
        this.namePromise = (cached = this.displayName || NAMES[this.ident]) ? success(cached) : !(this.model.service != null) ? error("No service") : (path = 'model' + (concatMap(function(d) {
          return '/' + d.name;
        }))(this.allDescriptors()), params = (set({
          format: 'json'
        }))(copy(this.subclasses)), this.model.service.get(path, params).then(get('display')).done(function(n) {
          var _name, _ref3;
          return (_ref3 = NAMES[_name = _this.ident]) != null ? _ref3 : NAMES[_name] = n;
        }));
      }
      return this.namePromise.done(cb);
    };

    PathInfo.prototype.getChildNodes = function() {
      var fld, _ref2, _ref3, _results;
      _ref3 = ((_ref2 = this.getEndClass()) != null ? _ref2.fields : void 0) || {};
      _results = [];
      for (_ in _ref3) {
        fld = _ref3[_];
        _results.push(this.append(fld));
      }
      return _results;
    };

    PathInfo.prototype.allDescriptors = function() {
      return [this.root].concat(this.descriptors);
    };

    PathInfo.prototype.toString = function() {
      return this.allDescriptors().map(get('name')).join('.');
    };

    PathInfo.prototype.getType = function() {
      var _ref2, _ref3;
      return ((_ref2 = this.end) != null ? (_ref3 = _ref2.type) != null ? _ref3.replace(/java\.lang\./, '') : void 0 : void 0) || this.getEndClass();
    };

    return PathInfo;

  })();

  PathInfo.prototype.toPathString = PathInfo.prototype.toString;

  PathInfo.parse = function(model, path, subclasses) {
    var cached, cd, descriptors, fld, ident, keyPath, part, parts, root;
    if (subclasses == null) {
      subclasses = {};
    }
    ident = makeKey(model, path, subclasses);
    if (cached = PARSED[ident]) {
      return cached;
    }
    parts = path.split('.');
    root = cd = model.classes[parts.shift()];
    keyPath = root.name;
    descriptors = (function() {
      var _i, _len, _ref2, _results;
      _results = [];
      for (_i = 0, _len = parts.length; _i < _len; _i++) {
        part = parts[_i];
        fld = (cd != null ? cd.fields[part] : void 0) || ((_ref2 = (cd = model.classes[subclasses[keyPath]])) != null ? _ref2.fields[part] : void 0);
        if (!fld) {
          throw new Error("Could not find " + part + " in " + cd + " when parsing " + path);
        }
        keyPath += "." + part;
        cd = model.classes[fld.type || fld.referencedType];
        _results.push(fld);
      }
      return _results;
    })();
    return PARSED[ident] = new PathInfo({
      root: root,
      model: model,
      descriptors: descriptors,
      subclasses: subclasses,
      ident: ident
    });
  };

  PathInfo.flushCache = function() {
    PARSED = {};
    return NAMES = {};
  };

  exports.PathInfo = PathInfo;

}).call(this);
