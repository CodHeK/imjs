(function(root) {
    if (typeof jQuery === 'undefined') {
        return null; 
    }
    var $ = jQuery;
    // jQuery.XDomainRequest.js
    // Author: Jason Moon - @JSONMOON
    // IE8+
    // see: https://github.com/MoonScript/jQuery-ajaxTransport-XDomainRequest
    if (!$.support.cors && window.XDomainRequest) {
        var httpRegEx = /^https?:\/\//i;
        var getOrPostRegEx = /^get|post$/i;
        var sameSchemeRegEx = new RegExp('^'+location.protocol, 'i');
        var jsonRegEx = /\/json/i;
        var xmlRegEx = /\/xml/i;

        var XDomainTransporter = function (userOptions, options) {
            this.userOptions = userOptions;
            this.options = options;
            this.userType = (userOptions.dataType||'').toLowerCase();
            _.bindAll(this);
        };
        XDomainTransporter.prototype.constructor = XDomainTransporter;
        XDomainTransporter.prototype.send = function(headers, complete) {
            this.xdr = new XDomainRequest();
            this.complete = complete;
            var xdr = this.xdr;
            if (/^\d+$/.test(this.userOptions.timeout)) {
                xdr.timeout = this.userOptions.timeout;
            }
            xdr.ontimeout = function() {
                complete(500, 'timeout');
            };
            xdr.onerror = function() {
                complete(500, 'error', { text: xdr.responseText });
            };
            xdr.onload = this.onLoad;
            var postData = (this.userOptions.data && $.param(this.userOptions.data)) || '';
            xdr.open(this.options.type, this.options.url);
            xdr.send(postData);
        };
        XDomainTransporter.prototype.abort = function() {
            if (xdr) {
                xdr.abort();
            }
        };
        XDomainTransporter.prototype.onLoad = function() {
            var xdr = this.xdr;
            var allResponseHeaders = 'Content-Length: ' + xdr.responseText.length + '\r\nContent-Type: ' + xdr.contentType;
            var status = {code: 200, message: 'success'};
            var responses = {text: xdr.responseText};
            try {
                if ((this.userType === 'json') || ((this.userType !== 'text') && jsonRegEx.test(xdr.contentType))) {
                    try {
                        responses.json = $.parseJSON(xdr.responseText);
                    } catch (e) {
                        status.code = 500;
                        status.message = 'parseerror';
                    }
                } else if ((this.userType === 'xml') || ((this.userType !== 'text') && xmlRegEx.test(xdr.contentType))) {
                    var doc = new ActiveXObject('Microsoft.XMLDOM');
                    doc.async = false;
                    try {
                        doc.loadXML(xdr.responseText);
                    } catch(e) {
                        doc = undefined;
                    }
                    if (!doc || !doc.documentElement || doc.getElementsByTagName('parsererror').length) {
                        status.code = 500;
                        status.message = 'parseerror';
                        throw 'Invalid XML: ' + xdr.responseText;
                    }
                    responses.xml = doc;
                }
            } catch (parseMessage) {
                throw parseMessage;
            } finally {
                this.complete(status.code, status.message, responses, allResponseHeaders);
            }
        };

        // ajaxTransport exists in jQuery 1.5+
        jQuery.ajaxTransport('text html xml json', function(options, userOptions, jqXHR){
            // XDomainRequests must be: asynchronous, GET or POST methods, HTTP or HTTPS protocol, and same scheme as calling page
            if (options.crossDomain && options.async && getOrPostRegEx.test(options.type) && httpRegEx.test(userOptions.url) && sameSchemeRegEx.test(userOptions.url)) {
                return new XDomainTransporter(userOptions, options);
            }
        });
        $.support.cors = true;
    }
}).call(this, typeof exports === 'undefined' ? this : exports);
// Generated by CoffeeScript 1.3.3
(function() {
  var Deferred, root, _base, _ref, _ref1,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  if (Array.prototype.map == null) {
    Array.prototype.map = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        _results.push(f(x));
      }
      return _results;
    };
  }

  if (Array.prototype.filter == null) {
    Array.prototype.filter = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        if (f(x)) {
          _results.push(x);
        }
      }
      return _results;
    };
  }

  if (Array.prototype.reduce == null) {
    Array.prototype.reduce = function(f, initValue) {
      var ret, x, xs, _i, _len;
      xs = this.slice();
      ret = initValue != null ? initValue : xs.pop();
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        ret = f(ret, x);
      }
      return ret;
    };
  }

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (typeof exports !== "undefined" && exports !== null) {
    Deferred = require('underscore.deferred').Deferred;
  } else {
    Deferred = root.jQuery.Deferred;
    if ((_ref = root.intermine) == null) {
      root.intermine = {};
    }
    if ((_ref1 = (_base = root.intermine).funcutils) == null) {
      _base.funcutils = {};
    }
    root = root.intermine.funcutils;
  }

  root.fold = function(init, f) {
    return function(xs) {
      var k, ret, v;
      if (xs.reduce != null) {
        return xs.reduce(f, init);
      } else {
        ret = init;
        for (k in xs) {
          v = xs[k];
          ret = ret != null ? f(ret, k, v) : {
            k: v
          };
        }
        return ret;
      }
    };
  };

  root.take = function(n) {
    return function(xs) {
      if (n != null) {
        return xs.slice(0, (n - 1) + 1 || 9e9);
      } else {
        return xs;
      }
    };
  };

  root.omap = function(f) {
    return function(o) {
      var domap;
      domap = exports.fold({}, function(a, k, v) {
        var kk, vv, _ref2;
        _ref2 = f(k, v), kk = _ref2[0], vv = _ref2[1];
        a[kk] = vv;
        return a;
      });
      return domap(o);
    };
  };

  root.copy = root.omap(function(k, v) {
    return [k, v];
  });

  root.partition = function(f) {
    return function(xs) {
      var falses, trues, x, _i, _len;
      trues = [];
      falses = [];
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        if (f(x)) {
          trues.push(x);
        } else {
          falses.push(x);
        }
      }
      return [trues, falses];
    };
  };

  root.concatMap = function(f) {
    return function(xs) {
      var fx, k, ret, v, x, _i, _len;
      ret = void 0;
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        fx = f(x);
        ret = (function() {
          var _ref2;
          if (ret === void 0) {
            return fx;
          } else if ((_ref2 = typeof fx) === 'string' || _ref2 === 'number') {
            return ret + fx;
          } else if (fx.slice != null) {
            return ret.concat(fx);
          } else {
            for (k in fx) {
              v = fx[k];
              ret[k] = v;
            }
            return ret;
          }
        })();
      }
      return ret;
    };
  };

  root.flatMap = root.concatMap;

  root.sum = root.concatMap(function() {});

  root.AND = function(a, b) {
    return a && b;
  };

  root.OR = function(a, b) {
    return a || b;
  };

  root.NOT = function(x) {
    return !x;
  };

  root.id = function(x) {
    return x;
  };

  root.invoke = function() {
    var args, name;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return function(obj) {
      var _ref2;
      if ((_ref2 = obj[name]) != null ? _ref2.apply : void 0) {
        return obj[name].apply(obj, args);
      } else {
        return Deferred().reject("No method: " + name).promise();
      }
    };
  };

  root.invokeWith = function(name, args, ctx) {
    if (args == null) {
      args = [];
    }
    if (ctx == null) {
      ctx = null;
    }
    return function(o) {
      return o[name].apply(ctx || o, args);
    };
  };

  root.get = function(name) {
    return function(obj) {
      return obj[name];
    };
  };

  root.set = function(name, value) {
    return function(obj) {
      var k, v;
      if (arguments.length === 2) {
        obj[name] = value;
      } else {
        for (k in name) {
          if (!__hasProp.call(name, k)) continue;
          v = name[k];
          obj[k] = v;
        }
      }
      return obj;
    };
  };

}).call(this);
"use strict";

(function(exports, IS_NODE) {

    /**
     * A module for encapsulating the metadata available to a
     * client.
     * @module intermine/Model
     */

    var _, Deferred;
    if (IS_NODE) {
        _ = require('underscore')._;
        Deferred = require('jquery-deferred').Deferred;
    } else {
        _ = exports._;
        Deferred = exports.jQuery.Deferred;
        if (typeof exports.intermine === 'undefined') {
            exports.intermine = {};
        }
        exports = exports.intermine;
    } 

    /**
     * A representation of the information contained in a path
     * expression. This class exposes the metadata available for this
     * path, and is aware of class constraints placed upon it.
     * @constructor
     * @param {Object} info The initial information used to construct this path.
     */
    var PathInfo = function(info) {
        _(this).extend(info);
        this.end = _(this.descriptors).last();
    };
    PathInfo.prototype.constructor = PathInfo;

    PathInfo.prototype.isRoot = function() {
        return this.descriptors.length == 0;
    };

    PathInfo.prototype.getEndClass = function() {
        var endClassName, endClass = null;
        if (this.isRoot()) {
            endClass = this.root;
        } else if (this.isClass()) {
            endClassName = this.subclasses[this.toString()] || this.end.referencedType;
            endClass = this.model.classes[endClassName];
        }
        return endClass;
    };

    PathInfo.prototype.getParent = function() {
        if (this.isRoot()) {
            throw "Root paths do not have a parent";
        }
        var data = _.extend({}, this, {descriptors: _(this.descriptors).initial(), displayName: null});
        return new PathInfo(data);
    };

    PathInfo.prototype.append = function(attr) {
        var type = this.getType();
        if (_(attr).isString()) {
            attr = type.fields[attr];
        }
        var data = _.extend({}, this, {descriptors: this.descriptors.concat([attr]), displayName: null});
        return new PathInfo(data);
    };

    PathInfo.prototype.isa = function(clazz) {
        var className = (clazz.name) ? clazz.name : clazz + "";
        var type = this.getType();
        var ancestors;
        if (className === type.name) {
            return true;
        } else {
            ancestors = this.model.getAncestorsOf(type);
            return _(ancestors).include(className);
        }
    };

    var _displayNameCache = {};

    PathInfo.prototype.getDisplayName = function(cb) {
        var wrapped, promise, self = this;
        var cacheKey = this.toString() + ":" + _.map(this.subclasses, function(v, k) {return k + "=" + v}).join(';');
        var displayName;
        if (this.displayName != null || _displayNameCache[cacheKey] != null) {
            promise = new Deferred();
            displayName = (this.displayName || _displayNameCache[cacheKey]);
            if (cb != null) {
                cb(displayName);
            }
            promise.resolve(displayName);
            return promise;
        }
            this.displayName = _displayNameCache[cacheKey];
        if (cb == null) {
            wrapped = function() {};
        } else {
            wrapped = function(resp) {
                self.displayName = resp.display;
                _displayNameCache[cacheKey] = resp.display;
                cb(resp.display);
            };
        }
        if (this.model.service == null) {
            throw new Error("Cannot fetch display name: no service");
        }
        var params = {format: 'json'};
        _.each(this.subclasses, function(v, k) {
            params[k] = v;
        });
        var slashPath = _.reduce(this.descriptors, function(a, d) { return a + "/" + d.name }, "/" + this.root.name);
        return this.model.service.makeRequest('model' + slashPath, params, wrapped);
    };

    PathInfo.prototype.getChildNodes = function() {
        var cls, flds, childNodes, i, l;
        childNodes = [];
        var self = this;
        if (!this.isAttribute()) {
            cls = this.getEndClass();
            flds = cls.fields;
            _.each(flds, function(fld, name) {
                childNodes.push(self.append(fld));
            });
        } 
        return childNodes;
    };


    var pistr = function() {
        var str = this.root.name;
        return _(this.descriptors).reduce(function(a, b) {return a + "." + b.name}, this.root.name);
    };

    PathInfo.prototype.toPathString = pistr;
    PathInfo.prototype.toString = pistr;

    PathInfo.prototype.isAttribute = function() {
        if (this.isRoot()) {
            return false;
        }
        return this.end && !this.end.referencedType;
    };


    PathInfo.prototype.isClass = function() {
        if (this.isRoot()) {
            return true;
        }
        return this.end && this.end.referencedType;
    };

    PathInfo.prototype.isReference = function() {
        return this.end && this.end.referencedType;
    };

    PathInfo.prototype.isCollection = function() {
        return this.end && this.end.isCollection;
    };

    PathInfo.prototype.containsCollection = function() {
        if (this.isRoot()) {
            return false;
        }
        return _(this.descriptors).any(function(d) {
            return d.isCollection;
        });
    };

    var Table = function(o) {
        _(this).extend(o);
        _(this.collections).each(function(coll) {
            coll.isCollection = true;
        });
        this.fields = _({}).extend(this.attributes, this.references, this.collections);
        this.allReferences = _({}).extend(this.references, this.collections);
    };

    // TODO: write unit tests.
    /**
        * Get the type of an attribute path. If the path represents a class or a reference, 
        * the class itself is returned, otherwise the name of the attribute type is returned, 
        * minus any "java.lang." prefix.
        *
        * @param path The path to get the type of
        * @return A class-descriptor, or an attribute type name.
        */
    PathInfo.prototype.getType = function() {
        return this.getEndClass() || this.end.type.replace(/java\.lang\./, "");
    };

    Table.prototype = {
        constructor: Table
    };

    Table.prototype.toString = function toString() {
        return "[Table name=" + this.name + "]"
    };

    var Model = function(model) {
        _(this).extend(model);

        // Promote classes to tables.
        var classes = this.classes;
        _(classes).each(function(cd, name) {
            classes[name] = new Table(cd);
        });

    };

    Model.prototype.constructor = Model;

    /**
    * Get the ClassDescriptor for a path. If the path is a root-path, it 
    * returns the class descriptor for the class named, otherwise it returns 
    * the class the last part resolves to. If the last part is an attribute, this
    * function returns "undefined".
    *
    * @param path The path to resolve.
    * @return A class descriptor object, or undefined.
    */
    Model.prototype.getCdForPath = function(path) {
        var parts = path.split(".");
        var cd = this.classes[parts.shift()];
        return _(parts).reduce(_(function (memo, fieldName) {
            var fields = _({}).extend(
                memo.attributes, memo.references, memo.collections);
            return this.classes[fields[fieldName].referencedType];
        }).bind(this), cd);
    };

    // TODO: write unit tests
    /**
        * Get an object describing the path defined by the arguments.
        *
        * @param path The path to be described.
        * @param subclasses An object mapping path {Str} -> type {Str}
        */
    Model.prototype.getPathInfo = function(path, subclasses) {
        var cacheKey, pathInfo, parts, cd, keyPath, ret, self = this;
        subclasses = subclasses || {};
        cacheKey = path + _.map(subclasses, function(v,k) {return k+"="+v; }).join(':');
        if (this.__pathinfos == null) {
            this.__pathinfos = {};
        }
        if (this.__pathinfos[cacheKey] != null) {
            return this.__pathinfos[cacheKey];
        }
        pathInfo = {};
        parts = path.split(".");
        cd = this.classes[parts.shift()];
        keyPath = cd.name;
        pathInfo.root = cd;
        pathInfo.model = this;
        pathInfo.descriptors = _(parts).map(function(fieldName) {
            var fields = _({}).extend(cd.attributes, cd.references, cd.collections);
            if (!fields[fieldName]) {
                cd = self.classes[subclasses[keyPath]];
                try {
                    fields = _({}).extend(cd.attributes, cd.references, cd.collections);
                } catch (e) {
                    throw new Error("Could not resolve " + path);
                }
            }
            keyPath += "." + fieldName;
            var fd = fields[fieldName];
            cd = fd.referencedType ? self.classes[fd.referencedType] : null;
            return fd;
        });
        pathInfo.subclasses = subclasses;

        ret = new PathInfo(pathInfo);
        this.__pathinfos[cacheKey] = ret;
        return ret;

    };



    // TODO: write unit tests.
    // TODO - move all uses to PathInfo
    /**
        * Determine if there are any collections mentioned in the given path. 
        * eg: 
        *   Department.employees.name -> true
        *   Department.company.name -> false
        *
        * @param path {String} The path to examine.
        * @return {Boolean} Whether or not there is any collection in the path.
        */
    Model.prototype.hasCollection = function(path) {
        var paths = []
            ,parts = path.split(".")
            ,bit, parent, cd;
        while (bit = parts.pop()) {
            parent = parts.join(".");
            if ((parent) && (cd = this.getCdForPath(parent))) {
                if (cd.collections[bit]) {
                    return true;
                }
            }
        }
        return false;
    };

    var _subclass_map = {};

    /**
        * Return the subclasses of a given class. The subclasses of a class
        * includes the class itself, and is thus equivalent to 
        * 'isAssignableTo' in java.
        */
    Model.prototype.getSubclassesOf = function(cls) {
        var self = this;
        if (cls in _subclass_map) {
            return _subclass_map[cls];
        }
        var ret = [cls];
        _(this.classes).each(function(c) {
            if (_(c["extends"]).include(cls)) {
                ret = ret.concat(self.getSubclassesOf(c.name));
            }
        });
        _subclass_map[cls] = ret;
        return ret;
    };

    /**
    * Get the full ancestry of a particular class.
    *
    * The returned ancestry never includes the root InterMineObject base class.
    */
    Model.prototype.getAncestorsOf = function(clazz) {
        clazz = (clazz && clazz.name) ? clazz : this.classes[clazz + ""];
        var ancestors = clazz["extends"].slice();
        _(ancestors).each(_(function(a) {
            if (!a.match(/InterMineObject$/)) {
                ancestors = _.union(ancestors, this.getAncestorsOf(a));
            }
        }).bind(this));
        return ancestors;
    }


    /**
    * Return the common type of two model classes, or null if there isn't one.
    */
    Model.prototype.findCommonTypeOf = function(classA, classB) {
        if (classB == null || classA == null || classA == classB) {
            return classA;
        }
        var allAncestorsOfA = this.getAncestorsOf(classA);
        var allAncestorsOfB = this.getAncestorsOf(classB);
        // If one is a superclass of the other, return it.
        if (_(allAncestorsOfA).include(classB)) {
            return classB;
        }
        if (_(allAncestorsOfB).include(classA)) {
            return classA;
        }
        // Return the first common ancestor

        return _.intersection(allAncestorsOfA, allAncestorsOfB).shift();
    };

    /**
    * Return the common type of 0 or more model classes, or null if there is none.
    *
    * @param model The data model for this service.
    * @classes {String[]} classes the model classes to try and get a common type of.
    */
    Model.prototype.findCommonTypeOfMultipleClasses = function(classes) {
        return _.reduce(classes, _(this.findCommonTypeOf).bind(this), classes.pop());
    };
    Model.NUMERIC_TYPES = ["int", "Integer", "double", "Double", "float", "Float"];
    Model.INTEGRAL_TYPES = ["int", "Integer"]
    Model.BOOLEAN_TYPES = ["boolean", "Boolean"];

    exports.Model = Model;
}).call(this, typeof exports === 'undefined' ? this : exports, typeof exports != 'undefined');

// Generated by CoffeeScript 1.3.3

/*
# @source: /src/user.coffee
#
# The User class represents the authenticated user's profile
# information. It provides access to methods to read an manipulate
# a user's preferences.
#
# @author: Alex Kalderimis
*/


(function() {
  var Deferred, IS_NODE, User, root, _;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (typeof exports === 'undefined') {
    IS_NODE = false;
    Deferred = root.jQuery.Deferred;
    _ = root._;
    if (typeof root.console === 'undefined') {
      root.console = {
        log: function() {},
        error: function() {}
      };
    }
    if (root.intermine === 'undefined') {
      root.intermine = {};
    }
    root = root.intermine;
  } else {
    IS_NODE = true;
    Deferred = require('jquery-deferred').Deferred;
    _ = require('underscore')._;
  }

  User = (function() {

    function User(service, _arg) {
      var _ref;
      this.service = service;
      this.username = _arg.username, this.preferences = _arg.preferences;
      this.hasPreferences = this.preferences != null;
      if ((_ref = this.preferences) == null) {
        this.preferences = {};
      }
    }

    User.prototype.setPreference = function(key, value) {
      var data;
      if (_.isString(key)) {
        data = {};
        data[key] = value;
      } else if (!(value != null)) {
        data = key;
      } else {
        return Deferred().reject("bad-arguments", "Incorrect arguments to setPreference");
      }
      return this.setPreferences(data);
    };

    User.prototype.setPreferences = function(prefs) {
      return this._do_pref_req(prefs, 'POST');
    };

    User.prototype.clearPreference = function(key) {
      return this._do_pref_req({
        key: key
      }, 'DELETE');
    };

    User.prototype.clearPreferences = function() {
      return this._do_pref_req({}, 'DELETE');
    };

    User.prototype.refresh = function() {
      return this._do_pref_req({}, 'GET');
    };

    User.prototype._do_pref_req = function(data, method) {
      var _this = this;
      return this.service.manageUserPreferences(method, data).done(function(prefs) {
        return _this.preferences = prefs;
      });
    };

    return User;

  })();

  root.User = User;

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var $, ACCEPT_HEADER, BufferedResponse, CHECKING_PIPE, DEFAULT_ERROR_HANDLER, DEFAULT_PROTOCOL, Deferred, ENRICHMENT_PATH, ERROR_PIPE, EventEmitter, HAS_PROTOCOL, HAS_SUFFIX, IDENTITY, IS_NODE, LISTS_PATH, LIST_OPERATION_PATHS, List, MODELS, MODEL_PATH, Model, PREF_PATH, QUERY_RESULTS_PATH, QUICKSEARCH_PATH, Query, REQUIRES, SUFFIX, SUMMARYFIELDS_PATH, SUMMARY_FIELDS, Service, TABLE_ROW_PATH, TEMPLATES_PATH, URL, URLENC, User, VERSIONS, VERSION_PATH, WHOAMI_PATH, WIDGETS, WIDGETS_PATH, WITH_OBJ_PATH, dejoin, get, getListFinder, http, intermine, invoke, jQuery, modeller, qs, root, set, to_query_string, wire_for_browser, wire_for_node, _, _get_or_fetch, _ref, _ref1, _ref2, _ref3,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  IS_NODE = typeof exports !== 'undefined';

  ACCEPT_HEADER = {
    "json": "application/json",
    "jsonobjects": "application/json;type=objects",
    "jsontable": "application/json;type=table",
    "jsonrows": "application/json;type=rows",
    "jsoncount": "application/json;type=count",
    "jsonp": "application/javascript",
    "jsonpobjects": "application/javascript;type=objects",
    "jsonptable": "application/javascript;type=table",
    "jsonprows": "application/javascript;type=rows",
    "jsonpcount": "application/javascript;type=count"
  };

  URLENC = "application/x-www-form-urlencoded";

  if (IS_NODE) {
    _ = require('underscore')._;
    Deferred = ($ = require('underscore.deferred')).Deferred;
    http = require('http');
    URL = require('url');
    qs = require('querystring');
    Model = require('./model').Model;
    Query = require('./query').Query;
    List = require('./lists').List;
    User = require('./user').User;
    _ref = require('./shiv'), get = _ref.get, set = _ref.set, invoke = _ref.invoke;
    EventEmitter = require('events').EventEmitter;
    BufferedResponse = require('buffered-response').BufferedResponse;
    to_query_string = qs.stringify;
    intermine = exports;
  } else {
    _ = root._, jQuery = root.jQuery;
    Deferred = ($ = jQuery).Deferred;
    if ((_ref1 = root.intermine) == null) {
      root.intermine = {};
    }
    to_query_string = jQuery.param;
    _ref2 = root.intermine, Model = _ref2.Model, Query = _ref2.Query, List = _ref2.List, User = _ref2.User;
    _ref3 = root.intermine.funcutils, get = _ref3.get, set = _ref3.set, invoke = _ref3.invoke;
    (function() {
      var converters, format, header;
      converters = {};
      for (format in ACCEPT_HEADER) {
        header = ACCEPT_HEADER[format];
        converters["text " + format] = jQuery.parseJSON;
      }
      return jQuery.ajaxSetup({
        accepts: ACCEPT_HEADER,
        contents: {
          json: /json/
        },
        converters: converters
      });
    })();
    intermine = root.intermine;
  }

  modeller = function(x) {
    if (Model != null) {
      return new Model(x);
    } else {
      return x;
    }
  };

  VERSIONS = {};

  MODELS = {};

  SUMMARY_FIELDS = {};

  WIDGETS = {};

  DEFAULT_PROTOCOL = "http://";

  VERSION_PATH = "version";

  TEMPLATES_PATH = "templates";

  LISTS_PATH = "lists";

  MODEL_PATH = "model";

  SUMMARYFIELDS_PATH = "summaryfields";

  QUERY_RESULTS_PATH = "query/results";

  QUICKSEARCH_PATH = "search";

  WIDGETS_PATH = "widgets";

  ENRICHMENT_PATH = "list/enrichment";

  WITH_OBJ_PATH = "listswithobject";

  LIST_OPERATION_PATHS = {
    merge: "lists/union",
    intersect: "lists/intersect",
    diff: "lists/diff"
  };

  WHOAMI_PATH = "user/whoami";

  TABLE_ROW_PATH = QUERY_RESULTS_PATH + '/tablerows';

  PREF_PATH = 'user/preferences';

  REQUIRES = function(required, got) {
    return "This service requires a service at version " + required + " or above. This one is at " + got;
  };

  IDENTITY = function(x) {
    return x;
  };

  HAS_PROTOCOL = /^https?:\/\//i;

  HAS_SUFFIX = /service\/?$/i;

  SUFFIX = "/service/";

  DEFAULT_ERROR_HANDLER = function(e) {
    var _ref4;
    if (IS_NODE && (e.stack != null)) {
      return console.error(e.stack);
    } else {
      if (typeof console !== "undefined" && console !== null) {
        return (_ref4 = console.error || console.log) != null ? _ref4.apply(console, arguments) : void 0;
      }
    }
  };

  ERROR_PIPE = function(xhr, textStatus, e) {
    try {
      return JSON.parse(xhr.responseText).error;
    } catch (e) {
      return textStatus;
    }
  };

  CHECKING_PIPE = function(response) {
    return Deferred(function() {
      if (response.wasSuccessful) {
        try {
          return this.resolve(response);
        } catch (e) {
          return this.reject(e, response);
        }
      } else {
        return this.reject(response.error, response);
      }
    });
  };

  dejoin = function(q) {
    var parts, view, _i, _len, _ref4;
    _ref4 = q.views;
    for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
      view = _ref4[_i];
      parts = view.split('.');
      if (parts.length > 2) {
        q.addJoin(parts.slice(1, -1).join('.'));
      }
    }
    return q;
  };

  _get_or_fetch = function(propName, store, path, key, cb) {
    var value, _ref4,
      _this = this;
    return (_ref4 = this[propName]) != null ? _ref4 : this[propName] = this.useCache && (value = store[this.root]) ? Deferred().resolve(value).promise().done(cb) : this.get(path).pipe(get(key)).done(cb, function(x) {
      return store[_this.root] = x;
    });
  };

  getListFinder = function(name) {
    return function(lists) {
      return Deferred(function() {
        var list;
        if (list = _.find(lists, function(l) {
          return l.name === name;
        })) {
          return this.resolve(list);
        } else {
          return this.reject("List \"" + name + "\" not found among: " + (lists.map(get('name'))));
        }
      });
    };
  };

  Service = (function() {

    function Service(_arg) {
      var loc, noCache, _ref4, _ref5,
        _this = this;
      this.root = _arg.root, this.token = _arg.token, this.errorHandler = _arg.errorHandler, this.DEBUG = _arg.DEBUG, this.help = _arg.help, noCache = _arg.noCache;
      this.query = __bind(this.query, this);

      this.fetchListsContaining = __bind(this.fetchListsContaining, this);

      this.fetchList = __bind(this.fetchList, this);

      this.fetchTemplates = __bind(this.fetchTemplates, this);

      this.tableRows = __bind(this.tableRows, this);

      this.rows = __bind(this.rows, this);

      this.records = __bind(this.records, this);

      this.table = __bind(this.table, this);

      this.findById = __bind(this.findById, this);

      this.count = __bind(this.count, this);

      if (this.root == null) {
        throw new Error("No service root provided. This is required");
      }
      if (!HAS_PROTOCOL.test(this.root)) {
        this.root = DEFAULT_PROTOCOL + this.root;
      }
      if (!HAS_SUFFIX.test(this.root)) {
        this.root = this.root + SUFFIX;
      }
      this.root = this.root.replace(/ics$/, "ice/");
      if ((_ref4 = this.errorHandler) == null) {
        this.errorHandler = DEFAULT_ERROR_HANDLER;
      }
      if ((_ref5 = this.help) == null) {
        this.help = 'no.help.available@dev.null';
      }
      this.useCache = !noCache;
      loc = IS_NODE ? '' : location.protocol + '//' + location.host;
      this.getFormat = function(intended) {
        if (intended == null) {
          intended = 'json';
        }
        if (!/jsonp/.test(intended)) {
          if (!(IS_NODE || jQuery.support.cors)) {
            if (loc.substring(0, _this.root.length) !== _this.root) {
              return intended.replace('json', 'jsonp');
            }
          }
        }
        return intended;
      };
    }

    Service.prototype.post = function(path, data) {
      if (data == null) {
        data = {};
      }
      return this.makeRequest('POST', path, data);
    };

    Service.prototype.get = function(path, data) {
      return this.makeRequest('GET', path, data);
    };

    Service.prototype.makeRequest = function(method, path, data, cb, indiv) {
      var errBack, opts, url, _ref4;
      if (method == null) {
        method = 'GET';
      }
      if (path == null) {
        path = '';
      }
      if (data == null) {
        data = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (indiv == null) {
        indiv = false;
      }
      if (_.isArray(cb)) {
        _ref4 = cb, cb = _ref4[0], errBack = _ref4[1];
      }
      if (_.isArray(data)) {
        data = _.foldl(data, (function(m, _arg) {
          var k, v;
          k = _arg[0], v = _arg[1];
          m[k] = v;
          return m;
        }), {});
      }
      url = this.root + path;
      if (errBack == null) {
        errBack = this.errorHandler;
      }
      if (this.token) {
        data.token = this.token;
      }
      data.format = this.getFormat(data.format);
      if (/jsonp/.test(data.format)) {
        data.method = method;
        method = 'GET';
        url += '?callback=?';
      }
      if (!this.supports(method)) {
        data.method = method;
        method = this.getEffectiveMethod(method);
      }
      if (method === 'DELETE') {
        url += '?' + to_query_string(data);
      }
      opts = {
        data: data,
        dataType: data.format,
        success: cb,
        error: errBack,
        url: url,
        type: method
      };
      return this.doReq(opts, indiv);
    };

    Service.prototype.supports = function() {
      return true;
    };

    Service.prototype.getEffectiveMethod = function(x) {
      return x;
    };

    Service.prototype.enrichment = function(opts, cb) {
      return this.get(ENRICHMENT_PATH, _.defaults({}, opts, {
        maxp: 0.05
      })).pipe(get('results'));
    };

    Service.prototype.search = function(options, cb) {
      var k, req, v, _ref4, _ref5;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (_.isFunction(options)) {
        _ref4 = [options, {}], cb = _ref4[0], options = _ref4[1];
      }
      if (_.isString(options)) {
        options = {
          q: options
        };
      }
      req = _.defaults({}, options, {
        q: ''
      });
      delete req.facets;
      if (options.facets) {
        _ref5 = options.facets;
        for (k in _ref5) {
          v = _ref5[k];
          req["facet_" + k] = v;
        }
      }
      return this.post(QUICKSEARCH_PATH, req).pipe(function(results) {
        return Deferred(function() {
          cb(results.results, results.facets);
          return this.resolve(results.results, results.facets);
        });
      });
    };

    Service.prototype.count = function(q, cb) {
      var req;
      if (q.toXML != null) {
        req = {
          query: q.toXML(),
          format: 'jsoncount'
        };
        return this.post(QUERY_RESULTS_PATH, req).pipe(get('count')).done(cb);
      } else {
        return this.query(q).pipe(this.count).done(cb);
      }
    };

    Service.prototype.findById = function(type, id, cb) {
      return this.query({
        from: type,
        select: ['**'],
        where: {
          id: id
        }
      }).pipe(dejoin).pipe(invoke('records')).pipe(get(0)).done(cb);
    };

    Service.prototype.find = function(type, term, cb) {
      return this.query({
        from: type,
        select: ['**'],
        where: [[type, 'LOOKUP', term]]
      }).pipe(dejoin).pipe(invoke('records')).done(cb);
    };

    Service.prototype.whoami = function(cb) {
      var _this = this;
      return this.fetchVersion().pipe(function(v) {
        var fn;
        fn = function(x) {
          return new User(_this, x);
        };
        if (v < 9) {
          return Deferred(function() {
            return this.reject(REQUIRES(9, v));
          });
        } else {
          try {
            return _this.get(WHOAMI_PATH).pipe(get('user')).pipe(fn).done(cb);
          } catch (e) {
            return Deferred(function() {
              return this.reject(e);
            });
          }
        }
      });
    };

    Service.prototype.doPagedRequest = function(q, path, page, format, cb) {
      var req,
        _this = this;
      if (page == null) {
        page = {};
      }
      if (q.toXML != null) {
        req = _.defaults({}, {
          query: q.toXML(),
          format: format
        }, page);
        return this.post(path, req).pipe(get('results')).done(cb);
      } else {
        return this.query(q).pipe(function(query) {
          return _this.doPagedRequest(query, path, page, format, cb);
        });
      }
    };

    Service.prototype.table = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsontable', cb);
    };

    Service.prototype.records = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsonobjects', cb);
    };

    Service.prototype.rows = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'json', cb);
    };

    Service.prototype.tableRows = function(q, page, cb) {
      return this.doPagedRequest(q, TABLE_ROW_PATH, page, 'json', cb);
    };

    Service.prototype.fetchTemplates = function(cb) {
      return this.get(TEMPLATES_PATH).pipe(get('templates')).done(cb);
    };

    Service.prototype.fetchLists = function(cb) {
      return this.findLists('', cb);
    };

    Service.prototype.findLists = function(name, cb) {
      var fn,
        _this = this;
      fn = function(ls) {
        var data, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = ls.length; _i < _len; _i++) {
          data = ls[_i];
          _results.push(new List(data, _this));
        }
        return _results;
      };
      return this.get(LISTS_PATH, {
        name: name
      }).pipe(get('lists')).pipe(fn).done(cb);
    };

    Service.prototype.fetchList = function(name, cb) {
      var _this = this;
      return this.fetchVersion().pipe(function(v) {
        if (v < 13) {
          return _this.fetchLists().pipe(getListFinder(name)).done(cb);
        } else {
          return _this.findLists(name).pipe(get(0)).done(cb);
        }
      });
    };

    Service.prototype.fetchListsContaining = function(opts, cb) {
      var fn,
        _this = this;
      fn = function(xs) {
        var x, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = xs.length; _i < _len; _i++) {
          x = xs[_i];
          _results.push(new List(x, _this));
        }
        return _results;
      };
      return this.get(WITH_OBJ_PATH, opts).pipe(get('lists')).pipe(fn).done(cb);
    };

    Service.prototype.combineLists = function(operation, options, cb) {
      var req;
      req = _.pick(options, 'name', 'description');
      req.tags = options.tags.join(';');
      req.lists = options.lists.join(';');
      return this.get(LIST_OPERATION_PATHS[operation], req).pipe(get('listName')).pipe(this.fetchList).done(cb);
    };

    Service.prototype.merge = function() {
      return this.combineLists.apply(this, ['merge'].concat(__slice.call(arguments)));
    };

    Service.prototype.intersect = function() {
      return this.combineLists.apply(this, ['intersect'].concat(__slice.call(arguments)));
    };

    Service.prototype.diff = function() {
      return this.combineLists.apply(this, ['diff'].concat(__slice.call(arguments)));
    };

    Service.prototype.fetchWidgets = function(cb) {
      return _get_or_fetch.call(this, 'widgets', WIDGETS, WIDGETS_PATH, 'widgets', cb);
    };

    Service.prototype.fetchModel = function(cb) {
      return _get_or_fetch.call(this, 'model', MODELS, MODEL_PATH, 'model').pipe(modeller).pipe(set({
        service: this
      })).done(cb);
    };

    Service.prototype.fetchSummaryFields = function(cb) {
      return _get_or_fetch.call(this, 'summaryFields', SUMMARY_FIELDS, SUMMARYFIELDS_PATH, 'classes', cb);
    };

    Service.prototype.fetchVersion = function(cb) {
      return _get_or_fetch.call(this, 'version', VERSIONS, VERSION_PATH, 'version', cb);
    };

    Service.prototype.query = function(options, cb) {
      var _this = this;
      return $.when(this.fetchModel(), this.fetchSummaryFields()).pipe(function(m, sfs) {
        var args, service;
        args = _.defaults({}, options, {
          model: m,
          summaryFields: sfs
        });
        service = _this;
        return Deferred(function() {
          this.fail(service.errorHandler);
          this.done(cb);
          try {
            return this.resolve(new Query(args, service));
          } catch (e) {
            return this.reject(e);
          }
        });
      });
    };

    Service.prototype.manageUserPreferences = function(method, data) {
      var s;
      s = this;
      return this.fetchVersion().pipe(function(v) {
        if (v >= 11) {
          return s.makeRequest(method, PREF_PATH, data).pipe(get('preferences'));
        } else {
          return Deferred(function() {
            return this.reject(REQUIRES(11, v));
          }).promise();
        }
      });
    };

    return Service;

  })();

  wire_for_node = function() {
    var PESKY_COMMA, blocking, iterReq, streaming;
    PESKY_COMMA = /,\s*$/;
    iterReq = function(format) {
      return function(q, page, cbs) {
        var doThis, onEnd, onErr, req, _ref4;
        if (page == null) {
          page = {};
        }
        if (cbs == null) {
          cbs = [];
        }
        if (!(cbs != null) && !((page.start != null) || (page.size != null))) {
          _ref4 = [{}, page], page = _ref4[0], cbs = _ref4[1];
        }
        if (_.isFunction(cbs)) {
          cbs = [cbs];
        }
        req = _.extend({
          format: format
        }, page, {
          query: q.toXML()
        });
        doThis = cbs[0], onErr = cbs[1], onEnd = cbs[2];
        return this.makeRequest('POST', QUERY_RESULTS_PATH, req, null, true).fail(onErr).done(invoke('each', doThis)).done(invoke('error', onErr)).done(invoke('done', onEnd));
      };
    };
    Service.prototype.rowByRow = iterReq('json');
    Service.prototype.recordByRecord = iterReq('jsonobjects');
    streaming = function(ret, opts) {
      return function(resp) {
        var char0, charZ, containerBuffer, iter, onEnd, onlyDefinedItems, toItem;
        containerBuffer = '';
        char0 = opts.data.format === 'json' ? '[' : '{';
        charZ = opts.data.format === 'json' ? ']' : '}';
        toItem = function(line, idx) {
          var lastChar, parsed;
          try {
            parsed = JSON.parse(line.replace(PESKY_COMMA, ''));
            return parsed;
          } catch (e) {
            containerBuffer += line;
            lastChar = line[line.length - 1];
            if (idx > 0 && (lastChar === ',' || (lastChar === char0 && line[0] === charZ))) {
              iter.emit('error', e, line);
            }
            return void 0;
          }
        };
        onlyDefinedItems = function(item) {
          return item != null;
        };
        onEnd = function() {
          var container;
          try {
            container = JSON.parse(containerBuffer);
            if (container.error) {
              return iter.emit('error', new Error(container.error));
            }
          } catch (e) {
            return iter.emit('error', "Mal-formed JSON response: " + containerBuffer);
          }
        };
        iter = new BufferedResponse(resp, 'utf8').map(toItem).filter(onlyDefinedItems).each(opts.success).error(opts.error).done(onEnd);
        return ret.resolve(iter);
      };
    };
    blocking = function(ret, opts) {
      return function(resp) {
        var containerBuffer;
        containerBuffer = '';
        ret.done(opts.success);
        resp.on('data', function(chunk) {
          return containerBuffer += chunk;
        });
        resp.on('error', function(e) {
          return ret.reject(e);
        });
        return resp.on('end', function() {
          var err, parsed;
          if (/json/.test(opts.data.format)) {
            if ('' === containerBuffer && resp.statusCode === 200) {
              return ret.resolve();
            } else {
              try {
                parsed = JSON.parse(containerBuffer);
                if (err = parsed.error) {
                  return ret.reject(new Error(err));
                } else {
                  return ret.resolve(parsed);
                }
              } catch (e) {
                if (resp.statusCode >= 400) {
                  return ret.reject(new Error(resp.statusCode));
                } else {
                  return ret.reject(new Error("Could not parse response to " + opts.type + " " + opts.url + ": '" + containerBuffer + "' (" + e + ")"));
                }
              }
            }
          } else {
            if (e = containerBuffer.match(/\[Error\] (\d+)(.*)/m)) {
              return ret.reject(new Error(e[2]));
            } else {
              return ret.resolve(containerBuffer);
            }
          }
        });
      };
    };
    return Service.prototype.doReq = function(opts, iter) {
      return Deferred(function() {
        var postdata, req, url, _ref4, _ref5, _ref6;
        this.fail(opts.error);
        this.done(opts.success);
        if (_.isString(opts.data)) {
          postdata = opts.data;
          if ((_ref4 = opts.type) === 'GET' || _ref4 === 'DELETE') {
            return ret.reject("Invalid request. " + opts.type + " requests must not have bodies");
          }
        } else {
          postdata = to_query_string(opts.data);
        }
        url = URL.parse(opts.url, true);
        url.method = opts.type;
        url.port = url.port || 80;
        url.headers = {
          'User-Agent': 'node-http/imjs',
          'Accept': ACCEPT_HEADER[opts.dataType]
        };
        if (((_ref5 = url.method) === 'GET' || _ref5 === 'DELETE') && _.size(opts.data)) {
          url.path += '?' + postdata;
        } else {
          url.headers['Content-Type'] = (opts.contentType || URLENC) + '; charset=UTF-8';
          url.headers['Content-Length'] = postdata.length;
        }
        req = http.request(url, (iter ? streaming : blocking)(this, opts));
        req.on('error', this.reject);
        if ((_ref6 = url.method) === 'POST' || _ref6 === 'PUT') {
          req.write(postdata);
        }
        return req.end();
      });
    };
  };

  wire_for_browser = function() {
    var iterReq, mapping, wrapCbs;
    if (typeof XDomainRequest !== "undefined" && XDomainRequest !== null) {
      mapping = {
        PUT: 'POST',
        DELETE: 'GET'
      };
      Service.prototype.getEffectiveMethod = function(x) {
        return mapping[x];
      };
      Service.prototype.supports = function(m) {
        return mapping[m] === m;
      };
    }
    wrapCbs = function(cbs) {
      var atEnd, doThis, err;
      if (_.isArray(cbs)) {
        doThis = cbs[0], err = cbs[1], atEnd = cbs[2];
        return [
          (function(rows) {
            return _.each(rows, doThis);
          }), err, atEnd
        ];
      } else {
        return [
          function(rows) {
            return _.each(rows, cbs);
          }
        ];
      }
    };
    iterReq = function(format) {
      return function(q, page, cbs) {
        var doThis, fail, onEnd, req, _cbs, _ref4;
        if (page == null) {
          page = {};
        }
        if (cbs == null) {
          cbs = [];
        }
        if (!(cbs != null) && !((page.start != null) || (page.size != null))) {
          _ref4 = [{}, page], page = _ref4[0], cbs = _ref4[1];
        }
        _cbs = wrapCbs(cbs);
        req = _.extend({
          format: format
        }, page, {
          query: q.toXML()
        });
        doThis = _cbs[0], fail = _cbs[1], onEnd = _cbs[2];
        return this.post(QUERY_RESULTS_PATH, req, _cbs).done(onEnd);
      };
    };
    Service.prototype.rowByRow = iterReq('json');
    Service.prototype.recordByRecord = iterReq('jsonobjects');
    return Service.prototype.doReq = function(opts) {
      var errBack;
      errBack = opts.error || this.errorHandler;
      opts.error = _.compose(errBack, ERROR_PIPE);
      return jQuery.ajax(opts).pipe(CHECKING_PIPE).fail(errBack);
    };
  };

  if (IS_NODE) {
    wire_for_node();
  } else {
    wire_for_browser();
  }

  Service.prototype.eachRow = Service.prototype.rowByRow;

  Service.prototype.eachRecord = Service.prototype.recordByRecord;

  Service.flushCaches = function() {
    MODELS = {};
    VERSIONS = {};
    SUMMARY_FIELDS = {};
    return WIDGETS = {};
  };

  Service.connect = function(opts) {
    return new Service(opts);
  };

  intermine.Service = Service;

  if (IS_NODE) {
    intermine.Model = Model;
    intermine.Query = Query;
    intermine.List = List;
    intermine.User = User;
  }

}).call(this);
// Generated by CoffeeScript 1.3.3
(function() {
  var $, CODES, Deferred, IS_NODE, LIST_PIPE, Query, conAttrs, conStr, conValStr, concatMap, decapitate, f, fold, get, getListResponseHandler, get_canonical_op, id, idConStr, mth, multiConStr, noValueConStr, partition, root, simpleConStr, take, toQueryString, typeConStr, _, _CLONE, _fn, _get_data_fetcher, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  if (typeof exports === 'undefined') {
    IS_NODE = false;
    _ = root._;
    _ref = root.intermine.funcutils, partition = _ref.partition, fold = _ref.fold, take = _ref.take, concatMap = _ref.concatMap, id = _ref.id, get = _ref.get;
    Deferred = ($ = root.jQuery).Deferred;
    _CLONE = function(o) {
      return root.jQuery.extend(true, {}, o);
    };
    toQueryString = function(req) {
      return root.jQuery.param(req);
    };
    if (typeof root.console === 'undefined') {
      root.console = {
        log: function() {},
        error: function() {}
      };
    }
    if (root.intermine === 'undefined') {
      root.intermine = {};
    }
    root = root.intermine;
  } else {
    IS_NODE = true;
    _ = require('underscore')._;
    Deferred = ($ = require('underscore.deferred')).Deferred;
    _CLONE = require('clone');
    toQueryString = require('querystring').stringify;
    _ref1 = require('./shiv'), partition = _ref1.partition, fold = _ref1.fold, take = _ref1.take, concatMap = _ref1.concatMap, id = _ref1.id, get = _ref1.get;
  }

  get_canonical_op = function(orig) {
    var canonical;
    canonical = _.isString(orig) ? Query.OP_DICT[orig.toLowerCase()] : null;
    if (!canonical) {
      throw "Illegal constraint operator: " + orig;
    }
    return canonical;
  };

  decapitate = function(x) {
    return x.substr(x.indexOf('.'));
  };

  getListResponseHandler = function(service, cb) {
    return function(data) {
      var name;
      if (cb == null) {
        cb = function() {};
      }
      name = data.listName;
      return service.fetchLists(function(ls) {
        var theList;
        theList = _.find(ls, function(l) {
          return l.name === name;
        });
        return cb(theList);
      });
    };
  };

  conValStr = function(v) {
    return "<value>" + (_.escape(v)) + "</value>";
  };

  conAttrs = function(c, names) {
    var k, v;
    return ((function() {
      var _results;
      _results = [];
      for (k in c) {
        v = c[k];
        if ((__indexOf.call(names, k) >= 0)) {
          _results.push("" + k + "=\"" + (_.escape(v)) + "\" ");
        }
      }
      return _results;
    })()).join('');
  };

  noValueConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'op', 'code'])) + "/>";
  };

  typeConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'type'])) + "/>";
  };

  simpleConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'op', 'code', 'value', 'extraValue'])) + "/>";
  };

  multiConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'op', 'code'])) + ">" + (concatMap(conValStr)(c.values)) + "</constraint>";
  };

  idConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'op', 'code'])) + "ids=\"" + (c.ids.join(',')) + "\"/>";
  };

  conStr = function(c) {
    var _ref2;
    if (c.values != null) {
      return multiConStr(c);
    } else if (c.ids != null) {
      return idConStr(c);
    } else if (!(c.op != null)) {
      return typeConStr(c);
    } else if (_ref2 = c.op, __indexOf.call(Query.NULL_OPS, _ref2) >= 0) {
      return noValueConStr(c);
    } else {
      return simpleConStr(c);
    }
  };

  LIST_PIPE = function(service) {
    return _.compose(service.fetchList, get('listName'));
  };

  CODES = [null, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];

  Query = (function() {
    var getPaths;

    Query.JOIN_STYLES = ['INNER', 'OUTER'];

    Query.BIO_FORMATS = ['gff3', 'fasta', 'bed'];

    Query.NULL_OPS = ['IS NULL', 'IS NOT NULL'];

    Query.ATTRIBUTE_VALUE_OPS = ["=", "!=", ">", ">=", "<", "<=", "CONTAINS", "LIKE", "NOT LIKE"];

    Query.MULTIVALUE_OPS = ['ONE OF', 'NONE OF'];

    Query.TERNARY_OPS = ['LOOKUP'];

    Query.LOOP_OPS = ['=', '!='];

    Query.LIST_OPS = ['IN', 'NOT IN'];

    Query.OP_DICT = {
      "=": "=",
      "==": "=",
      "eq": "=",
      "!=": "!=",
      "ne": "!=",
      ">": ">",
      "gt": ">",
      ">=": ">=",
      "ge": ">=",
      "<": "<",
      "lt": "<",
      "<=": "<=",
      "le": "<=",
      "contains": "CONTAINS",
      "CONTAINS": "CONTAINS",
      "like": "LIKE",
      "LIKE": "LIKE",
      "not like": "NOT LIKE",
      "NOT LIKE": "NOT LIKE",
      "lookup": "LOOKUP",
      "IS NULL": "IS NULL",
      "is null": "IS NULL",
      "IS NOT NULL": "IS NOT NULL",
      "is not null": "IS NOT NULL",
      "ONE OF": "ONE OF",
      "one of": "ONE OF",
      "NONE OF": "NONE OF",
      "none of": "NONE OF",
      "in": "IN",
      "not in": "NOT IN",
      "IN": "IN",
      "NOT IN": "NOT IN",
      "WITHIN": "WITHIN",
      "within": "WITHIN",
      "OVERLAPS": "OVERLAPS",
      "overlaps": "OVERLAPS",
      "ISA": "ISA",
      "isa": "ISA"
    };

    getPaths = function() {};

    Query.prototype.on = function(events, callback, context) {
      var calls, ev, list, tail, _ref2, _ref3, _ref4;
      events = events.split(/\s+/);
      calls = ((_ref2 = this._callbacks) != null ? _ref2 : this._callbacks = {});
      while (ev = events.shift()) {
        list = ((_ref3 = calls[ev]) != null ? _ref3 : calls[ev] = {});
        tail = ((_ref4 = list.tail) != null ? _ref4 : list.tail = (list.next = {}));
        tail.callback = callback;
        tail.context = context;
        list.tail = tail.next = {};
      }
      return this;
    };

    Query.prototype.bind = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.on.apply(this, args);
    };

    Query.prototype.trigger = function() {
      var all, args, calls, event, events, node, rest, tail;
      events = arguments[0], rest = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      calls = this._callbacks;
      if (!calls) {
        return this;
      }
      all = calls['all'];
      (events = events.split(/\s+/)).push(null);
      while (event = events.shift()) {
        if (all) {
          events.push({
            next: all.next,
            tail: all.tail,
            event: event
          });
        }
        if (!(node = calls[event])) {
          continue;
        }
        events.push({
          next: node.next,
          tail: node.tail
        });
      }
      while (node = events.pop()) {
        tail = node.tail;
        args = node.event ? [node.event].concat(rest) : rest;
        while ((node = node.next) !== tail) {
          node.callback.apply(node.context || this, args);
        }
      }
      return this;
    };

    function Query(properties, service) {
      this.expandStar = __bind(this.expandStar, this);

      this.adjustPath = __bind(this.adjustPath, this);

      var _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
        _this = this;
      _.defaults(this, {
        constraints: [],
        views: [],
        joins: {},
        constraintLogic: "",
        sortOrder: ""
      });
      if (properties == null) {
        properties = {};
      }
      this.displayNames = (_ref2 = properties.aliases) != null ? _ref2 : {};
      this.service = service != null ? service : {};
      this.model = (_ref3 = properties.model) != null ? _ref3 : {};
      this.summaryFields = (_ref4 = properties.summaryFields) != null ? _ref4 : {};
      this.root = (_ref5 = properties.root) != null ? _ref5 : properties.from;
      this.maxRows = (_ref6 = (_ref7 = properties.size) != null ? _ref7 : properties.limit) != null ? _ref6 : properties.maxRows;
      this.start = (_ref8 = (_ref9 = properties.start) != null ? _ref9 : properties.offset) != null ? _ref8 : 0;
      this.select(properties.views || properties.view || properties.select || []);
      this.addConstraints(properties.constraints || properties.where || []);
      this.addJoins(properties.joins || properties.join || []);
      this.orderBy(properties.sortOrder || properties.orderBy || []);
      if (properties.constraintLogic != null) {
        this.constraintLogic = properties.constraintLogic;
      }
      getPaths = function(root, depth) {
        var cd, others, ret;
        cd = _this.getPathInfo(root).getEndClass();
        ret = [root];
        others = !(cd && depth > 0) ? [] : _.flatten(_.map(cd.fields, function(r) {
          return getPaths("" + root + "." + r.name, depth - 1);
        }));
        return _.flatten(ret.concat(others));
      };
    }

    Query.prototype.removeFromSelect = function(unwanted) {
      var mapFn, so, uw, v;
      unwanted = _.isString(unwanted) ? [unwanted] : unwanted || [];
      mapFn = _.compose(this.expandStar, this.adjustPath);
      unwanted = _.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = unwanted.length; _i < _len; _i++) {
          uw = unwanted[_i];
          _results.push(mapFn(uw));
        }
        return _results;
      })());
      this.sortOrder = (function() {
        var _i, _len, _ref2, _ref3, _results;
        _ref2 = this.sortOrder;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          so = _ref2[_i];
          if (!(_ref3 = so.path, __indexOf.call(unwanted, _ref3) >= 0)) {
            _results.push(so);
          }
        }
        return _results;
      }).call(this);
      this.views = (function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.views;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          v = _ref2[_i];
          if (!(__indexOf.call(unwanted, v) >= 0)) {
            _results.push(v);
          }
        }
        return _results;
      }).call(this);
      this.trigger('remove:view', unwanted);
      return this.trigger('change:views', this.views);
    };

    Query.prototype.removeConstraint = function(con, silent) {
      var c, iscon, orig, reduced;
      if (silent == null) {
        silent = false;
      }
      orig = this.constraints;
      iscon = typeof con === 'string' ? (function(c) {
        return c.code === con;
      }) : (function(c) {
        var _ref2, _ref3;
        return (c.path === con.path) && (c.op === con.op) && (c.value === con.value) && (c.extraValue === con.extraValue) && (con.type === c.type) && (((_ref2 = c.values) != null ? _ref2.join('%%') : void 0) === ((_ref3 = con.values) != null ? _ref3.join('%%') : void 0));
      });
      reduced = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = orig.length; _i < _len; _i++) {
          c = orig[_i];
          if (!iscon(c)) {
            _results.push(c);
          }
        }
        return _results;
      })();
      if (reduced.length !== orig.length - 1) {
        throw "Did not remove a single constraint. original = " + orig + ", reduced = " + reduced;
      }
      this.constraints = reduced;
      if (!silent) {
        this.trigger('change:constraints');
        return this.trigger('removed:constraints', _.difference(orig, reduced));
      }
    };

    Query.prototype.addToSelect = function(views) {
      var p, toAdd, _i, _len, _ref2;
      views = _.isString(views) ? [views] : views || [];
      toAdd = _.map(views, _.compose(this.expandStar, this.adjustPath));
      _ref2 = _.flatten([toAdd]);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        p = _ref2[_i];
        this.views.push(p);
      }
      return this.trigger('add:view change:views', toAdd);
    };

    Query.prototype.select = function(views) {
      this.views = [];
      this.addToSelect(views);
      return this;
    };

    Query.prototype.adjustPath = function(path) {
      path = path && path.name ? path.name : "" + path;
      if (this.root != null) {
        if (!path.match("^" + this.root)) {
          path = this.root + "." + path;
        }
      } else {
        this.root = path.split('.')[0];
      }
      return path;
    };

    Query.prototype.getPossiblePaths = function(depth) {
      var _base, _ref2, _ref3;
      if (depth == null) {
        depth = 3;
      }
      if ((_ref2 = this._possiblePaths) == null) {
        this._possiblePaths = {};
      }
      return (_ref3 = (_base = this._possiblePaths)[depth]) != null ? _ref3 : _base[depth] = getPaths(this.root, depth);
    };

    Query.prototype.getPathInfo = function(path) {
      var adjusted, pi, _ref2;
      adjusted = this.adjustPath(path);
      pi = (_ref2 = this.model) != null ? typeof _ref2.getPathInfo === "function" ? _ref2.getPathInfo(adjusted, this.getSubclasses()) : void 0 : void 0;
      if (pi && adjusted in this.displayNames) {
        pi.displayName = this.displayNames[adjusted];
      }
      return pi;
    };

    Query.prototype.getSubclasses = function() {
      return fold({}, (function(a, c) {
        if (c.type != null) {
          a[c.path] = c.type;
        }
        return a;
      }))(this.constraints);
    };

    Query.prototype.getType = function(path) {
      return this.getPathInfo(path).getType();
    };

    Query.prototype.getViewNodes = function(path) {
      var toParentNode,
        _this = this;
      toParentNode = function(v) {
        return _this.getPathInfo(v).getParent();
      };
      return _.uniq(_.map(this.views, toParentNode), false, function(n) {
        return n.toPathString();
      });
    };

    Query.prototype.canHaveMultipleValues = function(path) {
      return this.getPathInfo(path).containsCollection();
    };

    Query.prototype.getQueryNodes = function() {
      var constrainedNodes, viewNodes,
        _this = this;
      viewNodes = this.getViewNodes();
      constrainedNodes = _.map(this.constraints, function(c) {
        var pi;
        pi = _this.getPathInfo(c.path);
        if (pi.isAttribute()) {
          return pi.getParent();
        } else {
          return pi;
        }
      });
      return _.uniq(viewNodes.concat(constrainedNodes), false, function(n) {
        return n.toPathString();
      });
    };

    Query.prototype.expandStar = function(path) {
      var cd, expand, fn, n, pathStem;
      if (/\*$/.test(path)) {
        pathStem = path.substr(0, path.lastIndexOf('.'));
        expand = function(x) {
          return pathStem + x;
        };
        cd = this.getType(pathStem);
        if (/\.\*$/.test(path)) {
          if (cd && this.summaryFields[cd.name]) {
            fn = _.compose(expand, decapitate);
            return (function() {
              var _i, _len, _ref2, _results;
              _ref2 = this.summaryFields[cd.name];
              _results = [];
              for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                n = _ref2[_i];
                if (!this.hasView(n)) {
                  _results.push(fn(n));
                }
              }
              return _results;
            }).call(this);
          }
        }
        if (/\.\*\*$/.test(path)) {
          fn = _.compose(expand, function(a) {
            return '.' + a.name;
          });
          return _.uniq(_.union(this.expandStar(pathStem + '.*'), _.map(cd.attributes, fn)));
        }
      }
      return path;
    };

    Query.prototype.isOuterJoin = function(p) {
      return this.joins[this.adjustPath(p)] === 'OUTER';
    };

    Query.prototype.hasView = function(v) {
      return this.views && _.include(this.views, this.adjustPath(v));
    };

    Query.prototype.count = function(cont) {
      if (this.service.count) {
        return this.service.count(this, cont);
      } else {
        throw new Error("This query has no service with count functionality attached.");
      }
    };

    Query.prototype.appendToList = function(target, cb) {
      var name, req, toRun, updateTarget;
      name = target && target.name ? target.name : '' + target;
      toRun = this.clone();
      if (toRun.views.length !== 1 || !toRun.views[0].match(/\.id$/)) {
        toRun.select(['id']);
      }
      req = {
        listName: name,
        query: toRun.toXML()
      };
      updateTarget = (target != null ? target.name : void 0) ? (function(list) {
        return target.size = list.size;
      }) : (function() {});
      return this.service.post('query/append/tolist', req).pipe(LIST_PIPE(this.service)).done(cb, updateTarget);
    };

    Query.prototype.saveAsList = function(options, cb) {
      var req, toRun;
      toRun = this.clone();
      if (toRun.views.length !== 1 || toRun.views[0] === null || !toRun.views[0].match(/\.id$/)) {
        toRun.select(['id']);
      }
      req = _.clone(options);
      req.listName = req.listName || req.name;
      req.query = toRun.toXML();
      if (options.tags) {
        req.tags = options.tags.join(';');
      }
      return this.service.post('query/tolist', req).pipe(LIST_PIPE(this.service)).done(cb);
    };

    Query.prototype.summarise = function(path, limit, cont) {
      return this.filterSummary(path, '', limit, cont);
    };

    Query.prototype.summarize = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.summarise.apply(this, args);
    };

    Query.prototype.filterSummary = function(path, term, limit, cont) {
      var parse, req, toRun, _ref2;
      if (cont == null) {
        cont = (function() {});
      }
      if (_.isFunction(limit)) {
        _ref2 = [limit, null], cont = _ref2[0], limit = _ref2[1];
      }
      path = this.adjustPath(path);
      toRun = this.clone();
      if (!_.include(toRun.views, path)) {
        toRun.views.push(path);
      }
      req = {
        query: toRun.toXML(),
        summaryPath: path,
        format: 'jsonrows'
      };
      if (limit) {
        req.size = limit;
      }
      if (term) {
        req.filterTerm = term;
      }
      parse = function(data) {
        return Deferred(function() {
          return this.resolve(data.results, data.uniqueValues, data.filteredCount);
        });
      };
      return this.service.post('query/results', req).pipe(parse).done(cont);
    };

    Query.prototype.clone = function(cloneEvents) {
      var cloned;
      cloned = _CLONE(this);
      if (cloneEvents) {
        cloned._callbacks = this._callbacks;
      } else {
        cloned._callbacks = {};
      }
      return cloned;
    };

    Query.prototype.next = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start + this.maxRows;
      }
      return clone;
    };

    Query.prototype.previous = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start - this.maxRows;
      } else {
        clone.start = 0;
      }
      return clone;
    };

    Query.prototype.getSortDirection = function(path) {
      var dir, so, _i, _len, _ref2;
      path = this.adjustPath(path);
      _ref2 = this.sortOrder;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        so = _ref2[_i];
        if (so.path === path) {
          dir = so.direction;
        }
      }
      return dir;
    };

    Query.prototype.isOuterJoined = function(path) {
      path = this.adjustPath(path);
      return _.any(this.joins, function(d, p) {
        return d === 'OUTER' && path.indexOf(p) === 0;
      });
    };

    Query.prototype.getOuterJoin = function(path) {
      var joinPaths,
        _this = this;
      path = this.adjustPath(path);
      joinPaths = _.sortBy(_.keys(this.joins), get('length')).reverse();
      return _.find(joinPaths, function(p) {
        return _this.joins[p] === 'OUTER' && path.indexOf(p) === 0;
      });
    };

    Query.prototype._parse_sort_order = function(input) {
      var k, so, v;
      so = input;
      if (_.isString(input)) {
        so = {
          path: input,
          direction: 'ASC'
        };
      } else if (!(input.path != null)) {
        k = _.keys(input)[0];
        v = _.values(input)[0];
        so = {
          path: k,
          direction: v
        };
      }
      so.path = this.adjustPath(so.path);
      so.direction = so.direction.toUpperCase();
      return so;
    };

    Query.prototype.addOrSetSortOrder = function(so) {
      var currentDirection, oe, _i, _len, _ref2;
      so = this._parse_sort_order(so);
      currentDirection = this.getSortDirection(so.path);
      if (!(currentDirection != null)) {
        return this.addSortOrder(so);
      } else if (currentDirection !== so.direction) {
        _ref2 = this.sortOrder;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          oe = _ref2[_i];
          if (oe.path === so.path) {
            oe.direction = so.direction;
          }
        }
        return this.trigger('change:sortorder', this.sortOrder);
      }
    };

    Query.prototype.addSortOrder = function(so) {
      this.sortOrder.push(this._parse_sort_order(so));
      this.trigger('add:sortorder', so);
      return this.trigger('change:sortorder', this.sortOrder);
    };

    Query.prototype.orderBy = function(oes) {
      var oe, _i, _len;
      this.sortOrder = [];
      for (_i = 0, _len = oes.length; _i < _len; _i++) {
        oe = oes[_i];
        this.addSortOrder(oe);
      }
      return this.trigger('set:sortorder', this.sortOrder);
    };

    Query.prototype.addJoins = function(joins) {
      var j, k, v, _i, _len, _results, _results1;
      if (_.isArray(joins)) {
        _results = [];
        for (_i = 0, _len = joins.length; _i < _len; _i++) {
          j = joins[_i];
          _results.push(this.addJoin(j));
        }
        return _results;
      } else {
        _results1 = [];
        for (k in joins) {
          v = joins[k];
          _results1.push(this.addJoin({
            path: k,
            style: v
          }));
        }
        return _results1;
      }
    };

    Query.prototype.addJoin = function(join) {
      var _ref2, _ref3, _ref4;
      if (_.isString(join)) {
        join = {
          path: join,
          style: 'OUTER'
        };
      }
      join.path = this.adjustPath(join.path);
      join.style = (_ref2 = (_ref3 = join.style) != null ? _ref3.toUpperCase() : void 0) != null ? _ref2 : join.style;
      if (_ref4 = join.style, __indexOf.call(Query.JOIN_STYLES, _ref4) < 0) {
        throw "Invalid join style: " + join.style;
      }
      this.joins[join.path] = join.style;
      return this.trigger('set:join', join.path, join.style);
    };

    Query.prototype.setJoinStyle = function(path, style) {
      if (style == null) {
        style = 'OUTER';
      }
      path = this.adjustPath(path);
      style = style.toUpperCase();
      if (this.joins[path] !== style) {
        this.joins[path] = style;
        this.trigger('change:joins', {
          path: path,
          style: style
        });
      }
      return this;
    };

    Query.prototype.addConstraints = function(constraints) {
      var c, con, path, _fn, _i, _len,
        _this = this;
      this.__silent__ = true;
      if (_.isArray(constraints)) {
        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          c = constraints[_i];
          this.addConstraint(c);
        }
      } else {
        _fn = function(path, con) {
          var constraint, k, keys, v, x, _ref2;
          constraint = {
            path: path
          };
          if (con === null) {
            constraint.op = 'IS NULL';
          } else if (_.isArray(con)) {
            constraint.op = 'ONE OF';
            constraint.values = con;
          } else if (_.isString(con) || _.isNumber(con)) {
            if (_ref2 = typeof con.toUpperCase === "function" ? con.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref2) >= 0) {
              constraint.op = con;
            } else {
              constraint.op = '=';
              constraint.value = con;
            }
          } else {
            keys = (function() {
              var _results;
              _results = [];
              for (k in con) {
                x = con[k];
                _results.push(k);
              }
              return _results;
            })();
            if (__indexOf.call(keys, 'isa') >= 0) {
              if (_.isArray(con.isa)) {
                constraint.op = k;
                constraint.values = con.isa;
              } else {
                constraint.type = con.isa;
              }
            } else {
              if (__indexOf.call(keys, 'extraValue') >= 0) {
                constraint.extraValue = con.extraValue;
              }
              for (k in con) {
                v = con[k];
                if (!(k !== 'extraValue')) {
                  continue;
                }
                constraint.op = k;
                if (_.isArray(v)) {
                  constraint.values = v;
                } else {
                  constraint.value = v;
                }
              }
            }
          }
          return _this.addConstraint(constraint);
        };
        for (path in constraints) {
          con = constraints[path];
          _fn(path, con);
        }
      }
      this.__silent__ = false;
      this.trigger('add:constraint');
      return this.trigger('change:constraints');
    };

    Query.prototype.addConstraint = function(constraint) {
      var a0, conArgs, v, _ref2;
      if (_.isArray(constraint)) {
        conArgs = constraint.slice();
        constraint = {
          path: conArgs.shift()
        };
        if (conArgs.length === 1) {
          a0 = conArgs[0];
          if (_ref2 = typeof a0.toUpperCase === "function" ? a0.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref2) >= 0) {
            constraint.op = a0;
          } else {
            constraint.type = a0;
          }
        } else if (conArgs.length >= 2) {
          constraint.op = conArgs[0];
          v = conArgs[1];
          if (_.isArray(v)) {
            constraint.values = v;
          } else {
            constraint.value = v;
          }
          if (conArgs.length === 3) {
            constraint.extraValue = conArgs[2];
          }
        }
      }
      constraint.path = this.adjustPath(constraint.path);
      if (constraint.type == null) {
        try {
          constraint.op = get_canonical_op(constraint.op);
        } catch (error) {
          throw new Error("Illegal operator: " + constraint.op);
        }
      }
      this.constraints.push(constraint);
      if ((this.constraintLogic != null) && this.constraintLogic !== '') {
        this.constraintLogic = "(" + this.constraintLogic + ") and " + CODES[this.constraints.length];
      }
      if (!this.__silent__) {
        this.trigger('add:constraint', constraint);
        this.trigger('change:constraints');
      }
      return this;
    };

    Query.prototype.getSorting = function() {
      return this.sortOrder.map(function(oe) {
        return "" + oe.path + " " + oe.direction;
      }).join(' ');
    };

    Query.prototype.getConstraintXML = function() {
      if (this.constraints.length) {
        return concatMap(conStr)(concatMap(id)(partition(function(c) {
          return c.type != null;
        })(this.constraints)));
      } else {
        return '';
      }
    };

    Query.prototype.getJoinXML = function() {
      var p, s, strs;
      strs = (function() {
        var _ref2, _results;
        _ref2 = this.joins;
        _results = [];
        for (p in _ref2) {
          s = _ref2[p];
          if (this.isRelevant(p) && s === 'OUTER') {
            _results.push("<join path=\"" + p + "\" style=\"OUTER\"/>");
          }
        }
        return _results;
      }).call(this);
      return strs.join('');
    };

    Query.prototype.toXML = function() {
      var attrs, headAttrs, k, v;
      attrs = {
        model: this.model.name,
        view: this.views.join(' '),
        sortOrder: this.getSorting(),
        constraintLogic: this.constraintLogic
      };
      if (this.name != null) {
        attrs.name = this.name;
      }
      headAttrs = ((function() {
        var _results;
        _results = [];
        for (k in attrs) {
          v = attrs[k];
          if (v) {
            _results.push(k + '="' + v + '"');
          }
        }
        return _results;
      })()).join(' ');
      return "<query " + headAttrs + " >" + (this.getJoinXML()) + (this.getConstraintXML()) + "</query>";
    };

    Query.prototype.isRelevant = function(p) {
      var pi, pstr;
      pi = this.getPathInfo(p);
      if (pi) {
        pstr = pi.toPathString();
        return _.any(_.union(this.views, _.pluck(this.constraints, 'path')), function(p) {
          return p.indexOf(pstr) === 0;
        });
      } else {
        return true;
      }
    };

    Query.prototype.fetchCode = function(lang, cb) {
      var req;
      req = {
        query: this.toXML(),
        lang: lang
      };
      return this.service.get('query/code', req).pipe(this.service.VERIFIER).pipe(get('code')).done(cb);
    };

    Query.prototype.save = function(name, cb) {
      var req,
        _this = this;
      if (name != null) {
        this.name = name;
      }
      req = {
        data: this.toXML(),
        contentType: "application/xml; charset=UTF-8",
        url: this.service.root + 'query',
        type: 'POST',
        dataType: 'json'
      };
      return this.service.doReq(req).pipe(this.service.VERIFIER).pipe(get('name')).done(cb, function(name) {
        return _this.name = name;
      });
    };

    Query.prototype.getCodeURI = function(lang) {
      var req, _ref2;
      req = {
        query: this.toXML(),
        lang: lang,
        format: 'text'
      };
      if (((_ref2 = this.service) != null ? _ref2.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/code?" + (toQueryString(req));
    };

    Query.prototype.getExportURI = function(format) {
      var req, _ref2;
      if (format == null) {
        format = 'tab';
      }
      if (__indexOf.call(Query.BIO_FORMATS, format) >= 0) {
        return this["get" + (format.toUpperCase()) + "URI"]();
      }
      req = {
        query: this.toXML(),
        format: format
      };
      if (((_ref2 = this.service) != null ? _ref2.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results?" + (toQueryString(req));
    };

    Query.prototype.__bio_req = function(types, n) {
      var olds, toRun,
        _this = this;
      toRun = this.clone();
      olds = toRun.views;
      toRun.views = take(n)(olds.map(function(v) {
        return _this.getPathInfo(v).getParent();
      }).filter(function(p) {
        return _.any(types, function(t) {
          return p.isa(t);
        });
      }).map(function(p) {
        return p.append('primaryIdentifier').toPathString();
      }));
      return {
        query: toRun.toXML(),
        format: 'text'
      };
    };

    Query.prototype._fasta_req = function() {
      return this.__bio_req(["SequenceFeature", 'Protein'], 1);
    };

    Query.prototype._gff3_req = function() {
      return this.__bio_req(['SequenceFeature']);
    };

    Query.prototype._bed_req = Query.prototype._gff3_req;

    return Query;

  })();

  Query.ATTRIBUTE_OPS = _.union(Query.ATTRIBUTE_VALUE_OPS, Query.MULTIVALUE_OPS, Query.NULL_OPS);

  Query.REFERENCE_OPS = _.union(Query.TERNARY_OPS, Query.LOOP_OPS, Query.LIST_OPS);

  _ref2 = Query.BIO_FORMATS;
  _fn = function(f) {
    var getMeth, reqMeth, uriMeth;
    reqMeth = "_" + f + "_req";
    getMeth = "get" + (f.toUpperCase());
    uriMeth = getMeth + "URI";
    Query.prototype[getMeth] = function(cb) {
      var req;
      if (cb == null) {
        cb = function() {};
      }
      req = this[reqMeth]();
      return this.service.post('query/results/' + f, req).done(cb);
    };
    return Query.prototype[uriMeth] = function(cb) {
      var req, _ref3;
      req = this[reqMeth]();
      if (((_ref3 = this.service) != null ? _ref3.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results/" + f + "?" + (toQueryString(req));
    };
  };
  for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
    f = _ref2[_i];
    _fn(f);
  }

  _get_data_fetcher = function(server_fn) {
    return function(page, cb) {
      if (cb == null) {
        cb = page;
      }
      page = _.isFunction(page) || !page ? {} : page;
      if (this.service[server_fn]) {
        _.defaults(page, {
          start: this.start,
          size: this.maxRows
        });
        return this.service[server_fn](this, page, cb);
      } else {
        throw new Error("Could not find " + server_fn + " at this service. Sorry.");
      }
    };
  };

  _ref3 = ['rowByRow', 'eachRow', 'recordByRecord', 'eachRecord', 'records', 'rows', 'table', 'tableRows'];
  for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
    mth = _ref3[_j];
    Query.prototype[mth] = _get_data_fetcher(mth);
  }

  root.Query = Query;

}).call(this);
"use strict";

(function(exports, IS_NODE) {

    var _, invoke;
    var TAGS_PATH = "list/tags";
    if (IS_NODE) {
        _ = require('underscore')._;
        invoke = require('./shiv').invoke;
    } else {
        _ = exports._;
        if (typeof exports.intermine == 'undefined') {
            exports.intermine = {};
        }
        invoke = intermine.funcutils.invoke;
        exports = intermine;
    }

    var isFolder = function(t) {
        return t.substr(0, t.indexOf(":")) === '__folder__';
    };
    var getFolderName = function(t) {
        return t.substr(t.indexOf(":") + 1);
    };

    var List = function(properties, service) {

        _(this).extend(properties);
        this.service = service;
        this.dateCreated = this.dateCreated ? new Date(this.dateCreated) : null;

        this.folders = _(this.tags).chain()
                                   .filter(isFolder)
                                   .map(getFolderName)
                                   .value();

        /**
         * Does this list have a given tag?
         *
         * @param t the tag this list may or may not have
         * @return Boolean whether or not this list has a given tag.
         */
        this.hasTag = function(t) {
            return _(this.tags).include(t);
        };

        /**
         * Delete this list. 
         *
         * The list MUST not be used after this function has been called.
         * @param cb a function to call upon completion of this action
         * @return jQuery.Deferred
         */
        this.del = function(cb) {
            cb = cb || function() {};
            return this.service.makeRequest('DELETE', 'lists', {name: this.name}, cb);
        };

        /**
         * Get the contents of this list.
         *
         * Each item in the list will be returned as an object with the summary-fields selected.
         * The results are unordered.
         * @param cb A function (optional) to call on completion of this action (default = no-op)
         * @return jQuery.Deferred
         */
        this.contents = function(cb) {
            cb = cb || function() {};
            var query = {select: ["*"], from: this.type, where: {}};
            query.where[this.type] = {IN: this.name};
            return this.service.query(query).pipe(invoke('records')).done(cb);
        };

        /**
         * Get enrichment statistics for this list.
         *
         * @see intermine.service#enrichment
         * @param data A map of key-value terms with the following keys: 'widget', 'maxp', 'correction', and optionally 'filter' and 'population'.
         * @param cb a function of the type [(results) -> void] to call on completion of this request.
         * @return jQuery.Deferred
         */
        this.enrichment = function(data, cb) {
            data.list = this.name;
            return this.service.enrichment(data, cb);
        };

        this.shareWithUser = function(recipient, cb) {
            var data = {'list': this.name, 'with': recipient};
            return this.service.post('lists/shares', data, cb);
        };

        this.inviteUserToShare = function(recipient, cb) {
            var data = {'list': this.name, 'to': recipient, 'notify': true};
            return this.service.post('lists/invitations', data, cb);
        };

    };

    exports.List = List;
}).call(this, typeof exports === 'undefined' ? this : exports, typeof exports != 'undefined');
        
